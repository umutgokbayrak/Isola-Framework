Ext.override(Ext.form.Radio,{    toggleValue : function() {        if(!this.checked){            var els = this.getParent().select('input[name='+this.el.dom.name+']');            els.each(function(el){                if (el.dom.value == null || el.dom.value == 'on' || el.dom.value == 'off' || el.dom.value != this.value) {                	el.dom.value = this.value;                }                if(el.dom.id == this.id){                    this.setValue(true);                }else{                    Ext.getCmp(el.dom.id).setValue(false);                }            }, this);        }    }});Ext.override(Ext.form.Checkbox, {    toggleValue : function(){        this.setValue(!this.checked);        if (this.checked) {            var el = this.el;			if (el.dom.value == null || el.dom.value == 'on' || el.dom.value == 'off' || el.dom.value != this.value) {				el.dom.value = this.value;			}        } else {        	this.el.dom.value =  null;        }    }});/*	Ajax Form Post'larda Turkce karakter sorunu icin */	Ext.apply(Ext.lib.Ajax,{	encoder: encodeURIComponent,	serializeForm: function(form) {		if(typeof form == 'string') {			form = (document.getElementById(form) || document.forms[form]);		}			var el, name, val, disabled, data = '', hasSubmit = false;		for (var i = 0; i < form.elements.length; i++) {			el = form.elements[i];			disabled = form.elements[i].disabled;			name = form.elements[i].name;			val = form.elements[i].value;				if (!disabled && name){				switch (el.type) {					case 'select-one':					case 'select-multiple':						for (var j = 0; j < el.options.length; j++) {							if (el.options[j].selected) {								if (Ext.isIE) {									data += this.encoder(name) + '=' + this.encoder(el.options[j].attributes['value'].specified ? el.options[j].value : el.options[j].text) + '&';								} else {									data += this.encoder(name) + '=' + this.encoder(el.options[j].hasAttribute('value') ? el.options[j].value : el.options[j].text) + '&';								}							}						}						break;					case 'radio':						if (el.checked) {							data += this.encoder(name) + '=' + this.encoder(val) + '&';						}						break;					case 'checkbox':						if (el.checked) {							data += this.encoder(name) + '=' + this.encoder(val) + '&';						}						break;					case 'file':					case undefined:					case 'reset':					case 'button':					    break;					case 'submit':						if(hasSubmit == false) {							data += this.encoder(name) + '=' + this.encoder(val) + '&';							hasSubmit = true;						}						break;					default:						data += this.encoder(name) + '=' + this.encoder(val) + '&';						break;		            }		        }		    }		    data = data.substr(0, data.length - 1);		    return data;		}	});Ext.lib.Ajax.encoder = function(str){	str = encodeURI(str);	str = str.replace(new RegExp("&",'g'), "%26");	str = str.replace(new RegExp(";",'g'), "%3B");	str = str.replace(new RegExp("[?]",'g'), "%3F");	return str;};//Ext.lib.Ajax.defaultPostHeader += '; charset=utf-8;';Ext.tree.ColumnTree = Ext.extend(Ext.tree.TreePanel, {    lines:false,    borderWidth: Ext.isBorderBox ? 0 : 2, // the combined left/right border for each cell    cls:'x-column-tree',        onRender : function(){        Ext.tree.ColumnTree.superclass.onRender.apply(this, arguments);        this.headers = this.body.createChild(            {cls:'x-tree-headers'},this.innerCt.dom);        var cols = this.columns, c;        var totalWidth = 0;        for(var i = 0, len = cols.length; i < len; i++){             c = cols[i];             totalWidth += c.width;             this.headers.createChild({                 cls:'x-tree-hd ' + (c.cls?c.cls+'-hd':''),                 cn: {                     cls:'x-tree-hd-text',                     html: c.header                 },                 style:'width:'+(c.width-this.borderWidth)+'px;'             });        }        this.headers.createChild({cls:'x-clear'});        // prevent floats from wrapping when clipped        this.headers.setWidth(totalWidth);        this.innerCt.setWidth(totalWidth);    }});Ext.tree.ColumnNodeUI = Ext.extend(Ext.tree.TreeNodeUI, {    focus: Ext.emptyFn, // prevent odd scrolling behavior    renderElements : function(n, a, targetNode, bulkRender){        this.indentMarkup = n.parentNode ? n.parentNode.ui.getChildIndent() : '';        var t = n.getOwnerTree();        var cols = t.columns;        var bw = t.borderWidth;        var c = cols[0];        var buf = [             '<li class="x-tree-node"><div ext:tree-node-id="',n.id,'" class="x-tree-node-el x-tree-node-leaf ', a.cls,'">',                '<div class="x-tree-col" style="width:',c.width-bw,'px;">',                    '<span class="x-tree-node-indent">',this.indentMarkup,"</span>",                    '<img src="', this.emptyIcon, '" class="x-tree-ec-icon x-tree-elbow">',                    '<img src="', a.icon || this.emptyIcon, '" class="x-tree-node-icon',(a.icon ? " x-tree-node-inline-icon" : ""),(a.iconCls ? " "+a.iconCls : ""),'" unselectable="on">',                    '<a hidefocus="on" class="x-tree-node-anchor" href="',a.href ? a.href : "#",'" tabIndex="1" ',                    a.hrefTarget ? ' target="'+a.hrefTarget+'"' : "", '>',                    '<span unselectable="on">', n.text || (c.renderer ? c.renderer(a[c.dataIndex], n, a) : a[c.dataIndex]),"</span></a>",                "</div>"];         for(var i = 1, len = cols.length; i < len; i++){             c = cols[i];             buf.push('<div class="x-tree-col ',(c.cls?c.cls:''),'" style="width:',c.width-bw,'px;">',                        '<div class="x-tree-col-text">',(c.renderer ? c.renderer(a[c.dataIndex], n, a) : a[c.dataIndex]),"</div>",                      "</div>");         }         buf.push(            '<div class="x-clear"></div></div>',            '<ul class="x-tree-node-ct" style="display:none;"></ul>',            "</li>");        if(bulkRender !== true && n.nextSibling && n.nextSibling.ui.getEl()){            this.wrap = Ext.DomHelper.insertHtml("beforeBegin",                                n.nextSibling.ui.getEl(), buf.join(""));        }else{            this.wrap = Ext.DomHelper.insertHtml("beforeEnd", targetNode, buf.join(""));        }        this.elNode = this.wrap.childNodes[0];        this.ctNode = this.wrap.childNodes[1];        var cs = this.elNode.firstChild.childNodes;        this.indentNode = cs[0];        this.ecNode = cs[1];        this.iconNode = cs[2];        this.anchor = cs[3];        this.textNode = cs[3].firstChild;    }});Ext.ns('Ext.ux.grid');/** * @class Ext.ux.grid.Search * @extends Ext.util.Observable * @param {Object} config configuration object * @constructor */Ext.ux.grid.Search = function(config) {	Ext.apply(this, config);	Ext.ux.grid.Search.superclass.constructor.call(this);}; // eo constructorExt.extend(Ext.ux.grid.Search, Ext.util.Observable, {	/**	 * @cfg {String} searchText Text to display on menu button	 */	 searchText:'Search'	/**	 * @cfg {String} searchTipText Text to display as input tooltip. Set to '' for no tooltip	 */ 	,searchTipText:'Type a text to search and press Enter'	/**	 * @cfg {String} selectAllText Text to display on menu item that selects all fields	 */	,selectAllText:'Select All'	/**	 * @cfg {String} position Where to display the search controls. Valid values are top and bottom (defaults to bottom)	 * Corresponding toolbar has to exist at least with mimimum configuration tbar:[] for position:top or bbar:[]	 * for position bottom. Plugin does NOT create any toolbar.	 */	,position:'bottom'	/**	 * @cfg {String} iconCls Icon class for menu button (defaults to icon-magnifier)	 */	,iconCls:'icon-magnifier'	/**	 * @cfg {String/Array} checkIndexes Which indexes to check by default. Can be either 'all' for all indexes	 * or array of dataIndex names, e.g. ['persFirstName', 'persLastName']	 */	,checkIndexes:'all'	/**	 * @cfg {Array} disableIndexes Array of index names to disable (not show in the menu), e.g. ['persTitle', 'persTitle2']	 */	/**	 * @cfg {String} dateFormat how to format date values. If undefined (the default) 	 * date is formatted as configured in colummn model	 */	,dateFormat:undefined	/**	 * @cfg {Boolean} showSelectAll Select All item is shown in menu if true (defaults to true)	 */	,showSelectAll:true	/**	 * @cfg {String} mode Use 'remote' for remote stores or 'local' for local stores. If mode is local	 * no data requests are sent to server the grid's store is filtered instead (defaults to 'remote')	 */	,mode:'remote'	/**	 * @cfg {Array} readonlyIndexes Array of index names to disable (show in menu disabled), e.g. ['persTitle', 'persTitle2']	 */	/**	 * @cfg {Number} width Width of input field in pixels (defaults to 100)	 */	,width:100	/**	 * @cfg {String} xtype xtype is usually not used to instantiate this plugin but you have a chance to identify it	 */	,xtype:'gridsearch'	/**	 * @cfg {Object} paramNames Params name map (defaults to {fields:'fields', query:'query'}	 */	,paramNames: {		 fields:'fields'		,query:'query'	}	/**	 * @cfg {String} shortcutKey Key to fucus the input field (defaults to r = Sea_r_ch). Empty string disables shortcut	 */	,shortcutKey:'r'	/**	 * @cfg {String} shortcutModifier Modifier for shortcutKey. Valid values: alt, ctrl, shift (defaults to alt)	 */	,shortcutModifier:'alt'	/**	 * @cfg {String} align 'left' or 'right' (defaults to 'left')	 */	/**	 * @cfg {Number} minLength force user to type this many character before he can make a search	 */	/**	 * @cfg {Ext.Panel/String} toolbarContainer Panel (or id of the panel) which contains toolbar we want to render	 * search controls to (defaults to this.grid, the grid this plugin is plugged-in into)	 */		// {{{	/**	 * private	 * @param {Ext.grid.GridPanel/Ext.grid.EditorGrid} grid reference to grid this plugin is used for	 */	,init:function(grid) {		this.grid = grid;		// setup toolbar container if id was given		if('string' === typeof this.toolbarContainer) {			this.toolbarContainer = Ext.getCmp(this.toolbarContainer);		}		// do our processing after grid render and reconfigure		grid.onRender = grid.onRender.createSequence(this.onRender, this);		grid.reconfigure = grid.reconfigure.createSequence(this.reconfigure, this);	} // eo function init	// }}}	// {{{	/**	 * private add plugin controls to <b>existing</b> toolbar and calls reconfigure	 */	,onRender:function() {		var panel = this.toolbarContainer || this.grid;		var tb;		if (this.position == 'bottom') {			tb = panel.bottomToolbar;		} else {			tb = panel.topToolbar;		}		// var tb = 'bottom' === this.position ? panel.bottomToolbar : panel.topToolbar;		// add menu		this.menu = new Ext.menu.Menu();		// handle position		if('right' === this.align) {			tb.addFill();		}		else {			if(0 < tb.items.getCount()) {				tb.addSeparator();			}		}		// add menu button		tb.add({			 text:this.searchText			,menu:this.menu			,iconCls:this.iconCls		});		// add input field (TwinTriggerField in fact)		this.field = new Ext.form.TwinTriggerField({			 width:this.width			,selectOnFocus:undefined === this.selectOnFocus ? true : this.selectOnFocus			,trigger1Class:'x-form-clear-trigger'			,trigger2Class:'x-form-search-trigger'			,onTrigger1Click:this.onTriggerClear.createDelegate(this)			,onTrigger2Click:this.onTriggerSearch.createDelegate(this)			,minLength:this.minLength		});		// install event handlers on input field		this.field.on('render', function() {			this.field.el.dom.qtip = this.searchTipText;			// install key map			var map = new Ext.KeyMap(this.field.el, [{				 key:Ext.EventObject.ENTER				,scope:this				,fn:this.onTriggerSearch			},{				 key:Ext.EventObject.ESC				,scope:this				,fn:this.onTriggerClear			}]);			map.stopEvent = true;		}, this, {single:true});		tb.add(this.field);		// reconfigure		this.reconfigure();		// keyMap		if(this.shortcutKey && this.shortcutModifier) {			var shortcutEl = this.grid.getEl();			var shortcutCfg = [{				 key:this.shortcutKey				,scope:this				,stopEvent:true				,fn:function() {					this.field.focus();				}			}];			shortcutCfg[0][this.shortcutModifier] = true;			this.keymap = new Ext.KeyMap(shortcutEl, shortcutCfg);		}	} // eo function onRender	// }}}	// {{{	/**	 * private Clear Trigger click handler	 */	,onTriggerClear:function() {		this.field.setValue('');		this.field.focus();		this.onTriggerSearch();	} // eo function onTriggerClear	// }}}	// {{{	/**	 * private Search Trigger click handler (executes the search, local or remote)	 */	,onTriggerSearch:function() {		if(!this.field.isValid()) {			return;		}		var val = this.field.getValue();		var store = this.grid.store;		// grid's store filter		if('local' === this.mode) {			store.clearFilter();			if(val) {				store.filterBy(function(r) {					var retval = false;					this.menu.items.each(function(item) {						if(!item.checked || retval) {							return;						}						var rv = r.get(item.dataIndex);						rv = rv instanceof Date ? rv.format(this.dateFormat || r.fields.get(item.dataIndex).dateFormat) : rv;						var re = new RegExp(val, 'gi');						retval = re.test(rv);					}, this);					if(retval) {						return true;					}					return retval;				}, this);			}			else {			}		}		// ask server to filter records		else {			// clear start (necessary if we have paging)			if(store.lastOptions && store.lastOptions.params) {				store.lastOptions.params[store.paramNames.start] = 0;			}			// get fields to search array			var fields = [];			this.menu.items.each(function(item) {				if(item.checked) {					fields.push(item.dataIndex);				}			});			// add fields and query to baseParams of store			delete(store.baseParams[this.paramNames.fields]);			delete(store.baseParams[this.paramNames.query]);			if (store.lastOptions && store.lastOptions.params) {				delete(store.lastOptions.params[this.paramNames.fields]);				delete(store.lastOptions.params[this.paramNames.query]);			}			if(fields.length) {				store.baseParams[this.paramNames.fields] = Ext.encode(fields);				store.baseParams[this.paramNames.query] = val;			}			// reload store			store.reload();		}	} // eo function onTriggerSearch	// }}}	// {{{	/**	 * @param {Boolean} true to disable search (TwinTriggerField), false to enable	 */	,setDisabled:function() {		this.field.setDisabled.apply(this.field, arguments);	} // eo function setDisabled	// }}}	// {{{	/**	 * Enable search (TwinTriggerField)	 */	,enable:function() {		this.setDisabled(false);	} // eo function enable	// }}}	// {{{	/**	 * Enable search (TwinTriggerField)	 */	,disable:function() {		this.setDisabled(true);	} // eo function disable	// }}}	// {{{	/**	 * private (re)configures the plugin, creates menu items from column model	 */	,reconfigure:function() {		// {{{		// remove old items		var menu = this.menu;		menu.removeAll();		// add Select All item plus separator		if(this.showSelectAll) {			menu.add(new Ext.menu.CheckItem({				 text:this.selectAllText				,checked:!(this.checkIndexes instanceof Array)				,hideOnClick:false				,handler:function(item) {					var checked = ! item.checked;					item.parentMenu.items.each(function(i) {						if(item !== i && i.setChecked && !i.disabled) {							i.setChecked(checked);						}					});				}			}),'-');		}		// }}}		// {{{		// add new items		var cm = this.grid.colModel;		Ext.each(cm.config, function(config) {			var disable = false;			if(config.header && config.dataIndex) {				Ext.each(this.disableIndexes, function(item) {					disable = disable ? disable : item === config.dataIndex;				});				if(!disable) {					menu.add(new Ext.menu.CheckItem({						 text:config.header						,hideOnClick:false						,checked:'all' === this.checkIndexes						,dataIndex:config.dataIndex					}));				}			}		}, this);		// }}}		// {{{		// check items		if(this.checkIndexes instanceof Array) {			Ext.each(this.checkIndexes, function(di) {				var item = menu.items.find(function(itm) {					return itm.dataIndex === di;				});				if(item) {					item.setChecked(true, true);				}			}, this);		}		// }}}		// {{{		// disable items		if(this.readonlyIndexes instanceof Array) {			Ext.each(this.readonlyIndexes, function(di) {				var item = menu.items.find(function(itm) {					return itm.dataIndex === di;				});				if(item) {					item.disable();				}			}, this);		}		// }}}	} // eo function reconfigure	// }}}}); // eo extend/** * @author Robert Williams (vtswingkid) * @version 1.0.3 */Ext.namespace('Ext.ux');Ext.ux.RadioGroup = Ext.extend(Ext.form.Field,  {    /**     * @cfg {String} focusClass The CSS class to use when the checkbox receives focus (defaults to undefined)     */    focusClass : undefined,    /**     * @cfg {String} fieldClass The default CSS class for the checkbox (defaults to "x-form-field")     */    fieldClass: "x-form-field",    /**     * @cfg {Boolean} checked True if the the checkbox should render already checked (defaults to false)     */    checked: false,    /**     * @cfg {String/Object} autoCreate A DomHelper element spec, or true for a default element spec (defaults to     * {tag: "input", type: "radio", autocomplete: "off"})     */    defaultAutoCreate : { tag: "input", type: 'radio', autocomplete: "off"},    /**     * @cfg {String} boxLabel The text that appears beside the checkbox     */		getId:function(){		//if multiple radios are defined use this information		if(this.radios && this.radios instanceof Array){			if(this.radios.length){				var r=this.radios[0];				this.value=r.value;				this.boxLabel=r.boxLabel;				this.checked=r.checked || false;				this.readOnly=r.readOnly || false;				this.disabled=r.disabled || false;				this.tabIndex=r.tabIndex;				this.cls=r.cls;				this.listeners=r.listeners;				this.style=r.style;				this.bodyStyle=r.bodyStyle;				this.hideParent=r.hideParent;				this.hidden=r.hidden;			}		}		Ext.ux.RadioGroup.superclass.getId.call(this);	},	// private    initComponent : function(){        Ext.ux.RadioGroup.superclass.initComponent.call(this);        this.addEvents(            /**             * @event change             * Fires when the radio value changes.             * @param {Ext.vx.RadioGroup} this This radio             * @param {Boolean} checked The new checked value             */            'check'        );    },    // private    onResize : function(){        Ext.ux.RadioGroup.superclass.onResize.apply(this, arguments);        if(!this.boxLabel){            this.el.alignTo(this.wrap, 'c-c');        }    },        // private    initEvents : function(){        Ext.ux.RadioGroup.superclass.initEvents.call(this);        this.el.on("click", this.onClick,  this);        this.el.on("change", this.onClick,  this);    },	// private    getResizeEl : function(){        return this.wrap;    },    // private    getPositionEl : function(){        return this.wrap;    },    /**     * Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide     * @method     */    markInvalid : Ext.emptyFn,    /**     * Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide     * @method     */    clearInvalid : Ext.emptyFn,    // private    onRender : function(ct, position){        Ext.ux.RadioGroup.superclass.onRender.call(this, ct, position);        this.wrap = this.el.wrap({cls: "x-form-check-wrap"});        if(this.boxLabel){            this.wrap.createChild({tag: 'label', htmlFor: this.el.id, cls: 'x-form-cb-label', html: this.boxLabel});        }		if(!this.isInGroup){			this.wrap.applyStyles({'padding-top':'2px'});		}        if(this.checked){            this.setChecked(true);        }else{            this.checked = this.el.dom.checked;        }		if (this.radios && this.radios instanceof Array) {			this.els=new Array();			this.els[0]=this.el;			for(var i=1;i<this.radios.length;i++){				var r=this.radios[i];				this.els[i]=new Ext.ux.RadioGroup({					renderTo:this.wrap,					hideLabel:true,					boxLabel:r.boxLabel,					checked:r.checked || false,					value:r.value,					name:this.name || this.id,					readOnly:r.readOnly || false,					disabled:r.disabled || false,					tabIndex:r.tabIndex,					cls:r.cls,					listeners:r.listeners,					style:r.style,					bodyStyle:r.bodyStyle,					hideParent:r.hideParent,					hidden:r.hidden,					isInGroup:true				});				if (this.horizontal) {					this.els[i].el.up('div.x-form-check-wrap').applyStyles({						'display': 'inline',						'padding-left': '5px'					});				}			}			if(this.hidden)this.hide();		}    },        initValue : function(){        if(this.value !== undefined){            this.el.dom.value=this.value;        }else if(this.el.dom.value.length > 0){            this.value=this.el.dom.value;        }    },	    // private    onDestroy : function(){		if (this.radios && this.radios instanceof Array) {			var cnt = this.radios.length;			for(var x=1;x<cnt;x++){				this.els[x].destroy();			}		}        if(this.wrap){            this.wrap.remove();        }        Ext.ux.RadioGroup.superclass.onDestroy.call(this);    },	setChecked:function(v){        if(this.el && this.el.dom){			var fire = false;			if(v != this.checked)fire=true;			this.checked=v;            this.el.dom.checked = this.checked;            this.el.dom.defaultChecked = this.checked;    	    if(fire)this.fireEvent("check", this, this.checked);	    }    },    /**     * Returns the value of the checked radio.     * @return {Mixed} value     */    getValue : function(){        if(!this.rendered) {            return this.value;        }        var p=this.el.up('form');//restrict to the form if it is in a form		if(!p)p=Ext.getBody();		var c=p.child('input[name='+this.el.dom.name+']:checked', true);		return (c)?c.value:this.value;    },	// private    onClick : function(){        if(this.el.dom.checked != this.checked){			var p = this.el.up('form');			if (!p) 				p = Ext.getBody();			var els = p.select('input[name=' + this.el.dom.name + ']');			els.each(function(el){				if (el.dom.id == this.id) {					this.setChecked(true);				}				else {					var e = Ext.getCmp(el.dom.id);					e.setChecked.apply(e, [false]);				}			}, this);        }    },    /**     * Checks the radio box with the matching value     * @param {Mixed} v     */    setValue : function(v){        if(!this.rendered) {            this.value=v;            return;        }        var p=this.el.up('form');//restrict to the form if it is in a form        if(!p)p=Ext.getBody();        var target = p.child('input[name=' + this.el.dom.name + '][value=' + v + ']', true);        if (target) target.checked = true;    }	});Ext.reg('ux-radiogroup', Ext.ux.RadioGroup);/***** LOV Field SG 31/07/2008*******/Ext.namespace('Ext.ux.form');Ext.ux.form.LovField = Ext.extend(Ext.form.TriggerField, {    defaultAutoCreate : {tag: "input", type: "text", size: "16",style:"cursor:default;", autocomplete: "off"},    triggerClass: 'x-form-search-trigger',    validateOnBlur: false,    // LOV window width    lovWidth: 300,    // LOV window height    lovHeight: 300,    // LOV window title    lovTitle: '',    // Multiple selection is possible?    multiSelect: false,    // If this option is true, data store reloads each time the LOV opens    alwaysLoadStore: false,    // LOV data provider, intance of Ext.grid.GridPanel or Ext.DataView    view: {},    // Which data store field will use for return    valueField: 'id',    // Which data store field will use for display    displayField: 'id',    // If multiple items are selected, they are joined with this character    valueSeparator: ',',    displaySeparator: ',',    // LOV window configurations    // autoScroll, layout, bbar and items configurations are not changed by this option    windowConfig: {},    showOnFocus : false,    minItem : 0,    minItemText : 'The minimum selected item number for this field is {0}',    maxItem : Number.MAX_VALUE,    maxItemText : 'The maximum selected item number for this field is {0}',    // Private    isStoreLoaded: false,    // Private    selections: [],    // Private    selectedRecords: [],        initComponent: function(){        if((this.view.xtype != 'grid' && this.view.xtype != 'dataview') &&        (!(this.view instanceof Ext.grid.GridPanel) && !(this.view instanceof Ext.DataView))){            throw "Ext.ux.form.LovField.view option must be instance of Ext.grid.GridPanel or Ext.DataView!";        }        Ext.ux.form.LovField.superclass.initComponent.call(this);        this.viewType = this.view.getXType();        if(this.viewType == 'grid' && !this.view.sm){            this.view.sm = this.view.getSelectionModel();        }        if(this.viewType == 'grid'){            this.view.sm.singleSelect = !this.multiSelect;        }else{            this.view.singleSelect = !this.multiSelect;            this.view.multiSelect = this.multiSelect;        }        if(Ext.type(this.displayField) == 'array'){            this.displayField = this.displayField.join('');        }        if (/<tpl(.*)<\/tpl>/.test(this.displayField) && !(this.displayFieldTpl instanceof Ext.XTemplate)) {            this.displayFieldTpl = new Ext.XTemplate(this.displayField).compile();        }        if(Ext.type(this.qtipTpl) == 'array'){            this.qtipTpl = this.qtipTpl.join('');        }        if(/<tpl(.*)<\/tpl>/.test(this.qtipTpl) && !(this.qtipTpl instanceof Ext.XTemplate) ){            this.qtipTpl = new Ext.XTemplate(this.qtipTpl).compile();        }        // If store was auto loaded mark it as loaded        if (this.view.store.autoLoad) {            this.isStoreLoaded = true;        }                 this.addEvents('selected','cancelled','showed');            },    onRender: function(ct, position){        if (this.isRendered) {            return;        }        //this.readOnly = true;        if(this.textarea){            this.defaultAutoCreate = {tag: "textarea", style:"cursor:default;width:124px;height:65px;", autocomplete: "off"};            this.displaySeparator = '\n';        }        Ext.ux.form.LovField.superclass.onRender.call(this, ct, position);        this.hiddenField = this.el.insertSibling({tag:'input', type:'hidden',        name: this.el.dom.getAttribute('name'), id: this.id + '-hidden'}, 'before', true);        // prevent input submission        this.el.dom.removeAttribute('name');        if(this.showOnFocus){            this.on('focus',this.onTriggerClick,this);        }        this.isRendered = true;    },    validateValue : function(value){        if( Ext.ux.form.LovField.superclass.validateValue.call(this, value)){            if(this.selectedRecords.length < this.minItem){                this.markInvalid(String.format(this.minItemText, this.minItem));                return false;            }            if(this.selectedRecords.length > this.maxItem){                this.markInvalid(String.format(this.maxItemText, this.maxItem));                return false;            }        }else{            return false;        }        return true;    },    getSelectedRecords : function(){        if(this.viewType == 'grid'){            this.selections = this.selectedRecords = this.view.sm.getSelections();        }else{            this.selections = this.view.getSelectedIndexes();            this.selectedRecords = this.view.getSelectedRecords();        }        return this.selectedRecords;    },    clearSelections : function(){        return (this.viewType == 'grid')? this.view.sm.clearSelections() : this.view.clearSelections();    },    select : function(selections){        if(this.viewType == 'grid'){            if(selections[0] instanceof Ext.data.Record){                this.view.sm.selectRecords(selections);            }else{                this.view.sm.selectRows(selections);            }        }else{            this.view.select(selections);        }    },    onSelect: function(){        var d = this.prepareValue(this.getSelectedRecords());        var returnValue = d.hv ? d.hv.join(this.valueSeparator) : '';        var displayValue = d.dv ? d.dv.join(this.displaySeparator) : '';        Ext.form.ComboBox.superclass.setValue.call(this, displayValue);        this.hiddenField.setAttribute('value', returnValue);        if(Ext.QuickTips){ // fix for floating editors interacting with DND            Ext.QuickTips.enable();        }                this.window.hide();               	this.fireEvent('selected', this);    },    onCancel: function(){        this.select(this.selections);        this.window.hide();               	this.fireEvent('cancelled', this);    },    prepareValue:function(sRec){        this.el.dom.qtip = '';        if (sRec.length > 0) {            var vals = {"hv": [],"dv": []};            Ext.each(sRec, function(i){                vals.hv.push(i.get(this.valueField));                if (this.displayFieldTpl) {                    vals.dv.push(this.displayFieldTpl.apply(i.data));                } else {                    vals.dv.push(i.get(this.displayField));                }                if(this.qtipTpl){                    this.el.dom.qtip += this.qtipTpl.apply(i.data);                }            }, this);            return vals;        }        return false;    },    getValue:function(){        var v = this.hiddenField.value;        if(v === this.emptyText || v === undefined){            v = '';        }        return v;    },    onTriggerClick: function(e){    	if (!this.fireEvent('showed', this)){    		return false;    	}        // Store Load        if (!this.isStoreLoaded) {            this.view.store.load();            this.isStoreLoaded = true;        } else if (this.alwaysLoadStore === true) {            this.view.store.reload();        }        this.windowConfig = Ext.apply(this.windowConfig,        {            title: this.lovTitle,            width: this.lovWidth,            height: this.lovHeight,            autoScroll: true,            layout: 'fit',            bbar: [            {text: 'Vazge&#231;', handler: this.onCancel,scope: this},            {text: 'Temizle', handler: function(){this.clearSelections();},scope: this},            '->',            {text: 'Se&#231;',handler: this.onSelect,scope: this}            ],            items: this.view        },{shadow: false, frame: true});        if(!this.window){            this.window = new Ext.Window(this.windowConfig);            this.window.setPagePosition(e.xy[0] + 16, e.xy[1] + 16);            this.window.on('beforeclose', function(){                this.window.hide();                return false;            }, this);            this.window.on('hide', this.validate, this);            this.view.on('dblclick', this.onSelect, this);        }        this.window.show();    }});Ext.reg('lovfield', Ext.ux.form.LovField);/********************************************/Ext.ux.form.DateTime = Ext.extend(Ext.form.Field, {    /**     * @cfg {String/Object} defaultAutoCreate DomHelper element spec     * Let superclass to create hidden field instead of textbox. Hidden will be submittend to server     */     defaultAutoCreate:{tag:'input', type:'hidden'}    /**     * @cfg {Number} timeWidth Width of time field in pixels (defaults to 100)     */    ,timeWidth:100    /**     * @cfg {String} dtSeparator Date - Time separator. Used to split date and time (defaults to ' ' (space))     */    ,dtSeparator:' '    /**     * @cfg {String} hiddenFormat Format of datetime used to store value in hidden field     * and submitted to server (defaults to 'Y-m-d H:i:s' that is mysql format)     */    ,hiddenFormat:'Y-m-d H:i:s'    /**     * @cfg {Boolean} otherToNow Set other field to now() if not explicly filled in (defaults to true)     */    ,otherToNow:true    /**     * @cfg {Boolean} emptyToNow Set field value to now on attempt to set empty value.     * If it is true then setValue() sets value of field to current date and time (defaults to false)     */    /**     * @cfg {String} timePosition Where the time field should be rendered. 'right' is suitable for forms     * and 'below' is suitable if the field is used as the grid editor (defaults to 'right')     */    ,timePosition:'right' // valid values:'below', 'right'    /**     * @cfg {String} dateFormat Format of DateField. Can be localized. (defaults to 'm/y/d')     */    ,dateFormat:'m/d/y'    /**     * @cfg {String} timeFormat Format of TimeField. Can be localized. (defaults to 'g:i A')     */    ,timeFormat:'g:i A'    /**     * @cfg {Object} dateConfig Config for DateField constructor.     */    /**     * @cfg {Object} timeConfig Config for TimeField constructor.     */    // {{{    /**     * private     * creates DateField and TimeField and installs the necessary event handlers     */    ,initComponent:function() {        // call parent initComponent        Ext.ux.form.DateTime.superclass.initComponent.call(this);        // create DateField        var dateConfig = Ext.apply({}, {             id:this.id + '-date'            ,format:this.dateFormat || Ext.form.DateField.prototype.format            ,width:this.timeWidth            ,selectOnFocus:this.selectOnFocus            ,listeners:{                  blur:{scope:this, fn:this.onBlur}                 ,focus:{scope:this, fn:this.onFocus}            }        }, this.dateConfig);        this.df = new Ext.form.DateField(dateConfig);        this.df.ownerCt = this;        delete(this.dateFormat);        // create TimeField        var timeConfig = Ext.apply({}, {             id:this.id + '-time'            ,format:this.timeFormat || Ext.form.TimeField.prototype.format            ,width:this.timeWidth            ,selectOnFocus:this.selectOnFocus            ,listeners:{                  blur:{scope:this, fn:this.onBlur}                 ,focus:{scope:this, fn:this.onFocus}            }        }, this.timeConfig);        this.tf = new Ext.form.TimeField(timeConfig);        this.tf.ownerCt = this;        delete(this.timeFormat);        // relay events        this.relayEvents(this.df, ['focus', 'specialkey', 'invalid', 'valid']);        this.relayEvents(this.tf, ['focus', 'specialkey', 'invalid', 'valid']);    } // eo function initComponent    // }}}    // {{{    /**     * private     * Renders underlying DateField and TimeField and provides a workaround for side error icon bug     */    ,onRender:function(ct, position) {        // don't run more than once        if(this.isRendered) {            return;        }        // render underlying hidden field        Ext.ux.form.DateTime.superclass.onRender.call(this, ct, position);        // render DateField and TimeField        // create bounding table        var t;        if('below' === this.timePosition || 'bellow' === this.timePosition) {            t = Ext.DomHelper.append(ct, {tag:'table',style:'border-collapse:collapse',children:[                 {tag:'tr',children:[{tag:'td', style:'padding-bottom:1px', cls:'ux-datetime-date'}]}                ,{tag:'tr',children:[{tag:'td', cls:'ux-datetime-time'}]}            ]}, true);        }        else {            t = Ext.DomHelper.append(ct, {tag:'table',style:'border-collapse:collapse',children:[                {tag:'tr',children:[                    {tag:'td',style:'padding-right:4px', cls:'ux-datetime-date'},{tag:'td', cls:'ux-datetime-time'}                ]}            ]}, true);        }        this.tableEl = t;//        this.wrap = t.wrap({cls:'x-form-field-wrap'});        this.wrap = t.wrap();        this.wrap.on("mousedown", this.onMouseDown, this, {delay:10});        // render DateField & TimeField        this.df.render(t.child('td.ux-datetime-date'));        this.tf.render(t.child('td.ux-datetime-time'));        // workaround for IE trigger misalignment bug        if(Ext.isIE && Ext.isStrict) {            t.select('input').applyStyles({top:0});        }        this.on('specialkey', this.onSpecialKey, this);        this.df.el.swallowEvent(['keydown', 'keypress']);        this.tf.el.swallowEvent(['keydown', 'keypress']);        // create icon for side invalid errorIcon        if('side' === this.msgTarget) {            var elp = this.el.findParent('.x-form-element', 10, true);            this.errorIcon = elp.createChild({cls:'x-form-invalid-icon'});            this.df.errorIcon = this.errorIcon;            this.tf.errorIcon = this.errorIcon;        }        // setup name for submit        this.el.dom.name = this.hiddenName || this.name || this.id;        // prevent helper fields from being submitted        this.df.el.dom.removeAttribute("name");        this.tf.el.dom.removeAttribute("name");        // we're rendered flag        this.isRendered = true;        // update hidden field        this.updateHidden();    } // eo function onRender    // }}}    // {{{    /**     * private     */    ,adjustSize:Ext.BoxComponent.prototype.adjustSize    // }}}    // {{{    /**     * private     */    ,alignErrorIcon:function() {        this.errorIcon.alignTo(this.tableEl, 'tl-tr', [2, 0]);    }    // }}}    // {{{    /**     * private initializes internal dateValue     */    ,initDateValue:function() {        this.dateValue = this.otherToNow ? new Date() : new Date(1970, 0, 1, 0, 0, 0);    }    // }}}    // {{{    /**     * Calls clearInvalid on the DateField and TimeField     */    ,clearInvalid:function(){        this.df.clearInvalid();        this.tf.clearInvalid();    } // eo function clearInvalid    // }}}    /**     * @private     * called from Component::destroy.      * Destroys all elements and removes all listeners we've created.     */    ,beforeDestroy:function() {        if(this.isRendered) {//            this.removeAllListeners();            this.wrap.removeAllListeners();            this.wrap.remove();            this.tableEl.remove();            this.df.destroy();            this.tf.destroy();        }    } // eo function beforeDestroy    // {{{    /**     * Disable this component.     * @return {Ext.Component} this     */    ,disable:function() {        if(this.isRendered) {            this.df.disabled = this.disabled;            this.df.onDisable();            this.tf.onDisable();        }        this.disabled = true;        this.df.disabled = true;        this.tf.disabled = true;        this.fireEvent("disable", this);        return this;    } // eo function disable    // }}}    // {{{    /**     * Enable this component.     * @return {Ext.Component} this     */    ,enable:function() {        if(this.rendered){            this.df.onEnable();            this.tf.onEnable();        }        this.disabled = false;        this.df.disabled = false;        this.tf.disabled = false;        this.fireEvent("enable", this);        return this;    } // eo function enable    // }}}    // {{{    /**     * private Focus date filed     */    ,focus:function() {        this.df.focus();    } // eo function focus    // }}}    // {{{    /**     * private     */    ,getPositionEl:function() {        return this.wrap;    }    // }}}    // {{{    /**     * private     */    ,getResizeEl:function() {        return this.wrap;    }    // }}}    // {{{    /**     * @return {Date/String} Returns value of this field     */    ,getValue:function() {        // create new instance of date        return this.dateValue ? new Date(this.dateValue) : '';    } // eo function getValue    // }}}    // {{{    /**     * @return {Boolean} true = valid, false = invalid     * private Calls isValid methods of underlying DateField and TimeField and returns the result     */    ,isValid:function() {        return this.df.isValid() && this.tf.isValid();    } // eo function isValid    // }}}    // {{{    /**     * Returns true if this component is visible     * @return {boolean}      */    ,isVisible : function(){        return this.df.rendered && this.df.getActionEl().isVisible();    } // eo function isVisible    // }}}    // {{{    /**      * private Handles blur event     */    ,onBlur:function(f) {        // called by both DateField and TimeField blur events        // revert focus to previous field if clicked in between        if(this.wrapClick) {            f.focus();            this.wrapClick = false;        }        // update underlying value        if(f === this.df) {            this.updateDate();        }        else {            this.updateTime();        }        this.updateHidden();        // fire events later        (function() {            if(!this.df.hasFocus && !this.tf.hasFocus) {                var v = this.getValue();                if(String(v) !== String(this.startValue)) {                    this.fireEvent("change", this, v, this.startValue);                }                this.hasFocus = false;                this.fireEvent('blur', this);            }        }).defer(100, this);    } // eo function onBlur    // }}}    // {{{    /**     * private Handles focus event     */    ,onFocus:function() {        if(!this.hasFocus){            this.hasFocus = true;            this.startValue = this.getValue();            this.fireEvent("focus", this);        }    }    // }}}    // {{{    /**     * private Just to prevent blur event when clicked in the middle of fields     */    ,onMouseDown:function(e) {        if(!this.disabled) {            this.wrapClick = 'td' === e.target.nodeName.toLowerCase();        }    }    // }}}    // {{{    /**     * private     * Handles Tab and Shift-Tab events     */    ,onSpecialKey:function(t, e) {        var key = e.getKey();        if(key === e.TAB) {            if(t === this.df && !e.shiftKey) {                e.stopEvent();                this.tf.focus();            }            if(t === this.tf && e.shiftKey) {                e.stopEvent();                this.df.focus();            }        }        // otherwise it misbehaves in editor grid        if(key === e.ENTER) {            this.updateValue();        }    } // eo function onSpecialKey    // }}}    // {{{    /**     * private Sets the value of DateField     */    ,setDate:function(date) {        this.df.setValue(date);    } // eo function setDate    // }}}    // {{{    /**      * private Sets the value of TimeField     */    ,setTime:function(date) {        this.tf.setValue(date);    } // eo function setTime    // }}}    // {{{    /**     * private     * Sets correct sizes of underlying DateField and TimeField     * With workarounds for IE bugs     */    ,setSize:function(w, h) {        if(!w) {            return;        }        if('below' === this.timePosition) {            this.df.setSize(w, h);            this.tf.setSize(w, h);            if(Ext.isIE) {                this.df.el.up('td').setWidth(w);                this.tf.el.up('td').setWidth(w);            }        }        else {            this.df.setSize(w - this.timeWidth - 4, h);            this.tf.setSize(this.timeWidth, h);            if(Ext.isIE) {                this.df.el.up('td').setWidth(w - this.timeWidth - 4);                this.tf.el.up('td').setWidth(this.timeWidth);            }        }    } // eo function setSize    // }}}    // {{{    /**     * @param {Mixed} val Value to set     * Sets the value of this field     */    ,setValue:function(val) {        if(!val && true === this.emptyToNow) {            this.setValue(new Date());            return;        }        else if(!val) {            this.setDate('');            this.setTime('');            this.updateValue();            return;        }        if ('number' === typeof val) {          val = new Date(val);        }        val = val ? val : new Date(1970, 0 ,1, 0, 0, 0);        var da, time;        if(val instanceof Date) {            this.setDate(val);            this.setTime(val);            this.dateValue = new Date(val);        }        else {            da = val.split(this.dtSeparator);            this.setDate(da[0]);            if(da[1]) {                if(da[2]) {                    // add am/pm part back to time                    da[1] += da[2];                }                this.setTime(da[1]);            }        }        this.updateValue();    } // eo function setValue    // }}}    // {{{    /**     * Hide or show this component by boolean     * @return {Ext.Component} this     */    ,setVisible: function(visible){        if(visible) {            this.df.show();            this.tf.show();        }else{            this.df.hide();            this.tf.hide();        }        return this;    } // eo function setVisible    // }}}    //{{{    ,show:function() {        return this.setVisible(true);    } // eo function show    //}}}    //{{{    ,hide:function() {        return this.setVisible(false);    } // eo function hide    //}}}    // {{{    /**     * private Updates the date part     */    ,updateDate:function() {        var d = this.df.getValue();        if(d) {            if(!(this.dateValue instanceof Date)) {                this.initDateValue();                if(!this.tf.getValue()) {                    this.setTime(this.dateValue);                }            }            this.dateValue.setMonth(0); // because of leap years            this.dateValue.setFullYear(d.getFullYear());            this.dateValue.setMonth(d.getMonth());            this.dateValue.setDate(d.getDate());        }        else {            this.dateValue = '';            this.setTime('');        }    } // eo function updateDate    // }}}    // {{{    /**     * private     * Updates the time part     */    ,updateTime:function() {        var t = this.tf.getValue();        if(t && !(t instanceof Date)) {            t = Date.parseDate(t, this.tf.format);        }        if(t && !this.df.getValue()) {            this.initDateValue();            this.setDate(this.dateValue);        }        if(this.dateValue instanceof Date) {            if(t) {                this.dateValue.setHours(t.getHours());                this.dateValue.setMinutes(t.getMinutes());                this.dateValue.setSeconds(t.getSeconds());            }            else {                this.dateValue.setHours(0);                this.dateValue.setMinutes(0);                this.dateValue.setSeconds(0);            }        }    } // eo function updateTime    // }}}    // {{{    /**     * private Updates the underlying hidden field value     */    ,updateHidden:function() {        if(this.isRendered) {            var value = this.dateValue instanceof Date ? this.dateValue.format(this.hiddenFormat) : '';            this.el.dom.value = value;        }    }    // }}}    // {{{    /**     * private Updates all of Date, Time and Hidden     */    ,updateValue:function() {        this.updateDate();        this.updateTime();        this.updateHidden();        return;    } // eo function updateValue    // }}}    // {{{    /**     * @return {Boolean} true = valid, false = invalid     * callse validate methods of DateField and TimeField     */    ,validate:function() {        return this.df.validate() && this.tf.validate();    } // eo function validate    // }}}    // {{{    /**     * Returns renderer suitable to render this field     * @param {Object} Column model config     */    ,renderer: function(field) {        var format = field.editor.dateFormat || Ext.ux.form.DateTime.prototype.dateFormat;        format += ' ' + (field.editor.timeFormat || Ext.ux.form.DateTime.prototype.timeFormat);        var renderer = function(val) {            var retval = Ext.util.Format.date(val, format);            return retval;        };        return renderer;    } // eo function renderer    // }}}}); // eo extend// register xtypeExt.reg('xdatetime', Ext.ux.form.DateTime);Ext.grid.RowExpander = function(config){    Ext.apply(this, config);    this.addEvents({        beforeexpand : true,        expand: true,        beforecollapse: true,        collapse: true    });    Ext.grid.RowExpander.superclass.constructor.call(this);    if(this.tpl){        if(typeof this.tpl == 'string'){            this.tpl = new Ext.Template(this.tpl);        }        this.tpl.compile();    }    this.state = {};    this.bodyContent = {};};Ext.extend(Ext.grid.RowExpander, Ext.util.Observable, {    header: "",    width: 20,    sortable: false,    fixed:true,    menuDisabled:true,    dataIndex: '',    id: 'expander',    lazyRender : true,    enableCaching: true,    getRowClass : function(record, rowIndex, p, ds){        p.cols = p.cols-1;        var content = this.bodyContent[record.id];        if(!content && !this.lazyRender){            content = this.getBodyContent(record, rowIndex);        }        if(content){            p.body = content;        }        return this.state[record.id] ? 'x-grid3-row-expanded' : 'x-grid3-row-collapsed';    },    init : function(grid){        this.grid = grid;        var view = grid.getView();        view.getRowClass = this.getRowClass.createDelegate(this);        view.enableRowBody = true;        grid.on('render', function(){            view.mainBody.on('mousedown', this.onMouseDown, this);        }, this);    },    getBodyContent : function(record, index){        if(!this.enableCaching){            return this.tpl.apply(record.data);        }        var content = this.bodyContent[record.id];        if(!content){            content = this.tpl.apply(record.data);            this.bodyContent[record.id] = content;        }        return content;    },    onMouseDown : function(e, t){        if(t.className == 'x-grid3-row-expander'){            e.stopEvent();            var row = e.getTarget('.x-grid3-row');            this.toggleRow(row);        }    },    renderer : function(v, p, record){        p.cellAttr = 'rowspan="2"';        return '<div class="x-grid3-row-expander">&#160;</div>';    },    beforeExpand : function(record, body, rowIndex){        if(this.fireEvent('beforeexpand', this, record, body, rowIndex) !== false){            if(this.tpl && this.lazyRender){                body.innerHTML = this.getBodyContent(record, rowIndex);            }            return true;        }else{            return false;        }    },    toggleRow : function(row){        if(typeof row == 'number'){            row = this.grid.view.getRow(row);        }        this[Ext.fly(row).hasClass('x-grid3-row-collapsed') ? 'expandRow' : 'collapseRow'](row);    },    expandRow : function(row){        if(typeof row == 'number'){            row = this.grid.view.getRow(row);        }        var record = this.grid.store.getAt(row.rowIndex);        var body = Ext.DomQuery.selectNode('tr:nth(2) div.x-grid3-row-body', row);        if(this.beforeExpand(record, body, row.rowIndex)){            this.state[record.id] = true;            Ext.fly(row).replaceClass('x-grid3-row-collapsed', 'x-grid3-row-expanded');            this.fireEvent('expand', this, record, body, row.rowIndex);        }    },    collapseRow : function(row){        if(typeof row == 'number'){            row = this.grid.view.getRow(row);        }        var record = this.grid.store.getAt(row.rowIndex);        var body = Ext.fly(row).child('tr:nth(1) div.x-grid3-row-body', true);        if(this.fireEvent('beforecollapse', this, record, body, row.rowIndex) !== false){            this.state[record.id] = false;            Ext.fly(row).replaceClass('x-grid3-row-expanded', 'x-grid3-row-collapsed');            this.fireEvent('collapse', this, record, body, row.rowIndex);        }    }});