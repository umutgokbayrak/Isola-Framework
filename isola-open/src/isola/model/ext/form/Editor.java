package isola.model.ext.form;import isola.helpers.JsHelper;import isola.model.ext.base.Component;import isola.model.ext.constants.XTypes;/** *  * A base editor field that handles displaying/hiding on demand and has some * built-in sizing *  * and event handling logic. *  *  *  * @author Umut Gokbayrak */public class Editor extends Component {	private static final long serialVersionUID = 5530487228092987046L;	private static final String TAG = "Ext.Editor";	/**	 * 	 * The position to align to (see Ext.Element.alignTo for more details,	 * defaults to "c-c?").	 */	public String alignment;	/**	 * 	 * True to cancel the edit when the escape key is pressed (defaults to	 * false)	 */	public boolean cancelOnEsc = false;	/**	 * 	 * True to complete the edit when the enter key is pressed (defaults to	 * false)	 */	public boolean completeOnEnter = false;	/**	 * 	 * True to constrain the editor to the viewport	 */	public boolean constrain = false;	/**	 * 	 * True to skip the the edit completion process (no save, no events fired)	 * if the	 * 	 * user completes an edit and the value has not changed (defaults to false).	 * Applies	 * 	 * only to string values - edits for other data types will never be ignored.	 */	public boolean ignoreNoChange = false;	/**	 * 	 * True to automatically revert the field value and cancel the edit when the	 * user	 * 	 * completes an edit and the field validation fails (defaults to true)	 */	public boolean revertInvalid = true;	/**	 * 	 * "sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for	 * 	 * bottom-right shadow (defaults to "frame")	 */	public String shadow;	/**	 * 	 * Handle the keydown/keypress events so they don't propagate (defaults to	 * true)	 */	public boolean swallowKeys = true;	/**	 * 	 * True to update the innerHTML of the bound element when the update	 * completes (defaults to false)	 */	public boolean updateEl = false;	/**	 * 	 * The data value of the underlying field (defaults to "")	 */	public String value;	/**	 * 	 * <p>	 * The registered xtype to create. This config option is not used when	 * passing a	 * 	 * config object into a constructor. This config option is used only when	 * lazy	 * 	 * instantiation is being used, and a child item of a Container is being	 * 	 * specified not as a fully instantiated Component, but as a Component	 * config	 * 	 * object. The xtype will be looked up at render time up to determine what	 * 	 * type of child Component to create.	 * </p>	 * 	 * 	 * 	 * @see XTypes <p>	 *      If you subclass Components to create your own Components, you may	 *      register	 * 	 *      them using Ext.ComponentMgr.registerType in order to be able to take	 *      advantage	 * 	 *      of lazy instantiation and rendering.	 *      </p>	 */	public String xtype = XTypes.editor;		public Editor() {		super();	}		protected void _postProcessToString() {		super._postProcessToString();		if (alignment != null)			put("alignment", alignment);		if (cancelOnEsc)			put("cancelOnEsc", cancelOnEsc);		if (completeOnEnter)			put("completeOnEnter", completeOnEnter);		if (constrain)			put("constrain", constrain);		if (ignoreNoChange)			put("ignoreNoChange", ignoreNoChange);		if (!revertInvalid)			put("revertInvalid", revertInvalid);		if (shadow != null)			put("shadow", shadow);		if (updateEl)			put("updateEl", updateEl);		if (value != null)			put("value", value);		if (xtype != null)			put("xtype", xtype);	}		@Override	public String toString() {		_postProcessToString();		return "new " + TAG + "(" + JsHelper.printJsObject(this) + ")";	}}