package isola.model.ext.base;import isola.helpers.JsHelper;import isola.model.core.JsArray;import isola.model.core.JsObject;import isola.model.ext.constants.XTypes;import java.util.StringTokenizer;import javolution.text.TextBuilder;/** *  * Base class for all Ext components. All subclasses of Component can * automatically *  * participate in the standard Ext component lifecycle of creation, rendering * and destruction. *  * They also have automatic support for basic hide/show and enable/disable * behavior. *  * Component allows any subclass to be lazy-rendered into any Ext.Container and * to be *  * automatically registered with the Ext.ComponentMgr so that it can be * referenced *  * at any time via Ext.getCmp. All visual widgets that require rendering into a * layout *  * should subclass Component (or Ext.BoxComponent if managed box model handling * is *  * required). *  *  *  * Every component has a specific xtype, which is its Ext-specific type name, *  * along with methods for checking the xtype like getXType and isXType. This is * the *  * list of all valid xtypes: *  *  *  * <pre> *  * xtype            Class * 
 * -------------    ------------------ * 
 * box              Ext.BoxComponent * 
 * button           Ext.Button * 
 * colorpalette     Ext.ColorPalette * 
 * component        Ext.Component * 
 * container        Ext.Container * 
 * cycle            Ext.CycleButton * 
 * dataview         Ext.DataView * 
 * datepicker       Ext.DatePicker * 
 * editor           Ext.Editor * 
 * editorgrid       Ext.grid.EditorGridPanel * 
 * grid             Ext.grid.GridPanel * 
 * paging           Ext.PagingToolbar * 
 * panel            Ext.Panel * 
 * progress         Ext.ProgressBar * 
 * splitbutton      Ext.SplitButton * 
 * tabpanel         Ext.TabPanel * 
 * treepanel        Ext.tree.TreePanel * 
 * viewport         Ext.ViewPort * 
 * window           Ext.Window * 
 *  * 
 * Toolbar components * 
 * --------------------------------------- * 
 * toolbar          Ext.Toolbar * 
 * tbbutton         Ext.Toolbar.Button * 
 * tbfill           Ext.Toolbar.Fill * 
 * tbitem           Ext.Toolbar.Item * 
 * tbseparator      Ext.Toolbar.Separator * 
 * tbspacer         Ext.Toolbar.Spacer * 
 * tbsplit          Ext.Toolbar.SplitButton * 
 * tbtext           Ext.Toolbar.TextItem * 
 *  * 
 * Form components * 
 * --------------------------------------- * 
 * form             Ext.FormPanel * 
 * checkbox         Ext.form.Checkbox * 
 * combo            Ext.form.ComboBox * 
 * datefield        Ext.form.DateField * 
 * field            Ext.form.Field * 
 * fieldset         Ext.form.FieldSet * 
 * hidden           Ext.form.Hidden * 
 * htmleditor       Ext.form.HtmlEditor * 
 * numberfield      Ext.form.NumberField * 
 * radio            Ext.form.Radio * 
 * textarea         Ext.form.TextArea * 
 * textfield        Ext.form.TextField * 
 * timefield        Ext.form.TimeField * 
 * trigger          Ext.form.TriggerField *  * </pre> *  *  *  * @author Umut Gokbayrak *  *  */public class Component extends Observable {	private static final long serialVersionUID = 1732267528880885654L;	private static final String TAG = "Ext.Component";	/**	 * 	 * Whether the component can move the Dom node when rendering (defaults to	 * true).	 */	public boolean allowDomMove = true;	/**	 * 	 * The id of the node, a DOM node or an existing Element corresponding	 * 	 * to a DIV that is already present in the document that specifies some	 * 	 * structural markup for this component. When applyTo is used, constituent	 * 	 * parts of the component can also be specified by id or CSS class name	 * 	 * within the main element, and the component being created may attempt to	 * 	 * create its subcomponents from that markup if applicable. Using this	 * 	 * config, a call to render() is not required. If applyTo is specified,	 * 	 * any value passed for renderTo will be ignored and the target element's	 * 	 * parent node will automatically be used as the component's container.	 */	public String applyTo;	/**	 * 	 * True if the component should check for hidden classes (e.g. 'x-hidden'	 * 	 * or 'x-hide-display') and remove them on render (defaults to false).	 */	public boolean autoShow = false;	/**	 * 	 * An optional extra CSS class that will be added to this component's	 * 	 * Element (defaults to ''). This can be useful for adding customized styles	 * 	 * to the component or any of its children using standard CSS rules.	 */	public String cls;	/**	 * 	 * An optional extra CSS class that will be added to this component's	 * 	 * container (defaults to ''). This can be useful for adding customized	 * 	 * styles to the container or any of its children using standard CSS rules.	 */	public String ctCls;	/**	 * 	 * CSS class added to the component when it is disabled (defaults to	 * 	 * "x-item-disabled").	 */	public String disabledClass;	/**	 * 	 * How this component should hidden. Supported values are "visibility"	 * 	 * (css visibility), "offsets" (negative offset position) and "display"	 * 	 * (css display) - defaults to "display".	 */	public String hideMode;	/**	 * 	 * True to hide and show the component's container when hide/show is	 * 	 * called on the component, false to hide and show the component itself	 * 	 * (defaults to false). For example, this can be used as a shortcut	 * 	 * for a hide button on a window by setting hide:true on the button when	 * 	 * adding it to its parent container.	 */	public boolean hideParent = false;	/**	 * 	 * The unique id of this component (defaults to an auto-assigned id).	 */	public String id;	/**	 * 	 * An object or array of objects that will provide custom functionality	 * 	 * for this component. The only requirement for a valid plugin is that	 * 	 * it contain an init method that accepts a reference of type Ext.Component.	 * 	 * 	 * 	 * When a component is created, if any plugins are available, the component	 * 	 * will call the init method on each plugin, passing a reference to itself.	 * 	 * Each plugin can then call methods or respond to events on the	 * 	 * component as needed to provide its functionality.	 */	public JsArray plugins;	/**	 * 	 * The id of the node, a DOM node or an existing Element that will be the	 * 	 * container to render this component into. Using this config, a call to	 * 	 * render() is not required.	 */	public String renderTo;	/**	 * 	 * An array of events that, when fired, should trigger this component to	 * 	 * save its state (defaults to none). These can be any types of events	 * supported	 * 	 * by this component, including browser or custom events	 * 	 * (e.g., ['click', 'customerchange']).	 * 	 * 	 * 	 * See stateful for an explanation of saving and restoring Component state.	 */	public JsArray stateEvents;	/**	 * 	 * The unique id for this component to use for state management purposes	 * 	 * (defaults to the component id). See stateful for an explanation of saving	 * 	 * and restoring Component state.	 */	public String stateId;	/**	 * 	 * <p>	 * A flag which causes the Component to attempt to restore the state of	 * 	 * internal properties from a saved state on startup.	 * </p>	 * 	 * 	 * 	 * <p>	 * For state saving to work, the state manager's provider must have been	 * 	 * set to an implementation of Ext.state.Provider which overrides the set	 * 	 * and get methods to save and recall name/value pairs. A built-in	 * 	 * implementation, Ext.state.CookieProvider is available.	 * </p>	 * 	 * 	 * 	 * <p>	 * To set the state provider for the current page:	 * </p>	 * 	 * <pre>	 * &lt;code&gt;	 * 
	 * Ext.state.Manager.setProvider(new Ext.state.CookieProvider());	 * 
	 * &lt;/code&gt;	 * </pre>	 * 	 * 	 * 	 * <p>	 * Components attempt to save state when one of the events listed in the	 * stateEvents	 * 	 * configuration fires.	 * </p>	 * 	 * 	 * 	 * <p>	 * You can perform extra processing on state save and restore by attaching	 * 	 * handlers to the beforestaterestore, staterestore, beforestatesave and	 * statesave	 * 	 * events.	 * </p>	 */	public boolean stateful = false;	/**	 * 	 * A custom style specification to be applied to this component's Element.	 * Should	 * 	 * be a valid argument to Ext.Element.applyStyles.	 */	public String style;	/**	 * 	 * <p>	 * The registered xtype to create. This config option is not used when	 * passing a	 * 	 * config object into a constructor. This config option is used only when	 * lazy	 * 	 * instantiation is being used, and a child item of a Container is being	 * 	 * specified not as a fully instantiated Component, but as a Component	 * config	 * 	 * object. The xtype will be looked up at render time up to determine what	 * 	 * type of child Component to create.	 * </p>	 * 	 * 	 * 	 * @see XTypes <p>	 *      If you subclass Components to create your own Components, you may	 *      register	 * 	 *      them using Ext.ComponentMgr.registerType in order to be able to take	 *      advantage	 * 	 *      of lazy instantiation and rendering.	 *      </p>	 */	public String xtype = XTypes.component;	/**	 * 	 * Where to place this component. Valid values are south, north, west, east,	 * center	 */	public String region;		/**
	 * 
	 */	public Component() {		super();	}		/**	 * 	 * Adds a CSS class to the component's underlying element.	 * 	 * 	 * 	 * @param cls	 *            The CSS class name to add	 */	public void addClass(String cls) {		if (cls != null) {			if (this.cls != null) {				this.cls = this.cls + " " + cls;			} else {				this.cls = cls;			}		}	}		/**	 * 	 * 	 * 	 * @param el	 */	public void applyToMarkup(String el) {		this.applyTo = el;	}		/**	 * 	 * Returns the id of this component.	 * 	 * 	 * 	 * @return	 */	public String getId() {		return id;	}		/**	 * 	 * Gets the xtype for this component as registered with Ext.ComponentMgr.	 * 	 * For a list of all available xtypes, see the Ext.Component header.	 * 	 * 	 * 	 * Example usage:	 * 	 * <pre>	 * &lt;code&gt;	 * 
	 * var t = new Ext.form.TextField();	 * 
	 * alert(t.getXType());  // alerts 'textfield'	 * 
	 * &lt;/code&gt;	 * </pre>	 * 	 * 	 * 	 * @see XTypes	 * 	 * @return	 */	public String getXtype() {		return xtype;	}		/**	 * 	 * Checks to see if this object has any listeners for a specified event	 * 	 * 	 * 	 * @return	 */	public boolean hasListener() {		JsObject tmp = getListeners();		return (tmp.get("listeners") != null);	}		/**	 * 	 * Removes a CSS class from the component's underlying element.	 * 	 * 	 * 	 * @param cls	 */	public void removeClass(String cls) {		if (this.cls != null) {			TextBuilder tb = new TextBuilder();			StringTokenizer token = new StringTokenizer(this.cls, " ");			String tmp = null;			while (token.hasMoreTokens()) {				tmp = token.nextToken();				if (!tmp.equals(cls)) {					tb.append(tmp).append(" ");				}			}			String out = tb.toString();			out.substring(0, out.length() - 1);			this.cls = out;		}	}		@Override	protected void _postProcessToString() {		super._postProcessToString();		if (!allowDomMove)			put("allowDomMove", allowDomMove);		if (applyTo != null)			put("applyTo", applyTo);		if (autoShow)			put("autoShow", autoShow);		if (cls != null)			put("cls", cls);		if (ctCls != null)			put("ctCls", ctCls);		if (disabledClass != null)			put("disabledClass", disabledClass);		if (hideMode != null)			put("hideMode", hideMode);		if (hideParent)			put("hideParent", hideParent);		if (id != null)			put("id", id);		if (plugins != null)			put("plugins", plugins);		if (renderTo != null)			put("renderTo", renderTo);		if (stateEvents != null)			put("stateEvents", stateEvents);		if (stateId != null)			put("stateId", stateId);		if (stateful)			put("stateful", stateful);		if (style != null)			put("style", style);		if (xtype != null && !xtype.equals(XTypes.component)) {			if (xtype != null)				put("xtype", xtype);		}		if (region != null)			put("region", region);	}		@Override	public String toString() {		_postProcessToString();		return "new " + TAG + "(" + JsHelper.printJsObject(this) + ")";	}}