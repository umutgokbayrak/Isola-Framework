package isola.model.ext.data;import isola.helpers.JsHelper;import isola.model.core.JsObject;import isola.model.core.JsVariableImpl;import isola.model.ext.base.Observable;/** *  * <p> * The Store class encapsulates a client side cache of Record objects which * provide input data *  * for Components such as the GridPanel, the ComboBox, or the DataView * </p> *  *  *  * <p> * A Store object uses its configured implementation of DataProxy to access a * data object unless *  * you call loadData directly and pass in your data. * </p> *  *  *  * <p> * A Store object has no knowledge of the format of the data returned by the * Proxy. * </p> *  *  *  * <p> * A Store object uses its configured implementation of DataReader to create * Record instances *  * from the data object. These Records are cached and made available through * accessor functions. * </p> *  *  *  * @author Umut Gokbayrak */public class Store extends Observable {	private static final long serialVersionUID = 2748590535427330712L;	private static final String TAG = "Ext.data.Store";	/**	 * 	 * If passed, this store's load method is automatically called after	 * creation with the autoLoad	 * 	 * object	 */	public boolean autoLoad = false;	/**	 * 	 * An object containing properties which are to be sent as parameters on any	 * HTTP request	 */	public JsObject baseParams;	/**	 * 	 * Inline data to be loaded when the store is initialized.	 */	public JsVariableImpl data;	/**	 * 	 * The Proxy object which provides access to a data object.	 */	public DataProxy proxy;	/**	 * 	 * True to clear all modified record information each time the store is	 * loaded or when a record	 * 	 * is removed. (defaults to false).	 */	public boolean pruneModifiedRecords = false;	/**	 * 	 * The DataReader object which processes the data object and returns an	 * Array of Ext.data.Record	 * 	 * objects which are cached keyed by their id property.	 */	public DataReader reader;	/**	 * 	 * <p>	 * True if sorting is to be handled by requesting the Proxy to provide a	 * refreshed version	 * 	 * of the data object in sorted order, as opposed to sorting the Record	 * cache in place	 * 	 * (defaults to false).	 * </p>	 * 	 * 	 * 	 * <p>	 * If remote sorting is specified, then clicking on a column header causes	 * the current	 * 	 * page to be requested from the server with the addition of the following	 * two parameters:	 * </p>	 * 	 * <ul>	 * 	 * <li>	 * 	 * <strong>sort(String):</strong>The name (as specified in the Record's	 * Field definition)	 * 	 * of the field to sort on.	 * 	 * </li>	 * 	 * <li>	 * 	 * <strong>dir(String):</strong>The direction of the sort, "ASC" or "DESC"	 * (case-sensitive).	 * 	 * </li>	 * 	 * </ul>	 */	public boolean remoteSort = false;	/**	 * 	 * A config object in the format: {field: "fieldName", direction:	 * "ASC|DESC"}. The direction	 * 	 * property is case-sensitive.	 */	public JsObject sortInfo;	/**	 * 	 * If passed, the id to use to register with the StoreMgr	 */	public String storeId;	/**	 * 	 * If passed, an HttpProxy is created for the passed URL	 */	public String url;		@Override	protected void _postProcessToString() {		super._postProcessToString();		if (autoLoad)			put("autoLoad", autoLoad);		if (baseParams != null)			put("baseParams", baseParams);		if (data != null)			put("data", data);		if (proxy != null)			put("proxy", proxy);		if (pruneModifiedRecords)			put("pruneModifiedRecords", pruneModifiedRecords);		if (reader != null)			put("reader", reader);		if (remoteSort)			put("remoteSort", remoteSort);		if (sortInfo != null)			put("sortInfo", sortInfo);		if (storeId != null)			put("storeId", storeId);		if (url != null)			put("url", url);	}		@Override	public String toString() {		_postProcessToString();		return "new " + TAG + "(" + JsHelper.printJsObject(this) + ")";	}}