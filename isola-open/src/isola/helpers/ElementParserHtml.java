package isola.helpers;import isola.model.core.LabelValuePair;import isola.model.html.core.ElementInt;import isola.model.html.core.TextNode;import isola.utility.Utility;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;import java.util.Locale;/** * Parses HTML Element Classes and generates HTML output * by the reflection API *  * @author Umut Gokbayrak */public class ElementParserHtml {	/**	 * 	 * This method parses the child elements and generates the HTML	 * representation for them	 * @param element	 * @return HTML For child nodes	 */	public static String getChildrenOutput(Object element) {		String fullHTML = getToStringOut(element);		String childOut = fullHTML.substring(fullHTML.indexOf(">") + 1, fullHTML.lastIndexOf("</"));		return childOut;	}		/**	 * 	 * Returns the HTML Tag for the element	 * 	 * 	 * 	 * @param element	 * 	 * @return tag name like: div, table, tr, td	 */	public static String getTag(ElementInt element) {		Class<?> cls = element.getClass();		String valTag = null;		try {			Method mtdTag = cls.getDeclaredMethod("getTag");			Object objTag = mtdTag.invoke(element);			if (objTag != null) {				valTag = objTag.toString();			}		} catch (Throwable e1) {			e1.printStackTrace();		}		return valTag;	}		/**	 * 	 * Parses the Element and returns a List of LabelValuePair's containing	 * 	 * all the attributes as valid HTML form. This method is not recursive so it	 * doesn't	 * 	 * branch the child elements.	 * 	 * 	 * 	 * @param element	 * 	 * @return	 */	public static List<LabelValuePair> getAttributeMap(ElementInt element) {		Class<?> cls = element.getClass();		List<LabelValuePair> result = new ArrayList<LabelValuePair>();		Field fields[] = null;		Method methods[] = null;		while (cls != null) {			fields = cls.getDeclaredFields();			methods = cls.getDeclaredMethods();			if (fields != null && methods != null) {				Field tmpField = null;				for (int i = 0; i < fields.length; i++) {					try {						tmpField = fields[i];						String name = tmpField.getName();						// attribute names starting with underscores are used						// internally so						// they are ommitted from displayed						if (name != null && !name.startsWith("_") && !name.equals("children") && !name.equals("tag")) {							String methodName = getGetterMethodNameFromAttribute(name);							for (int j = 0; j < methods.length; j++) {								try {									if (methods[j].getName().equals(methodName)) {										Method mtd = cls.getDeclaredMethod(methodName);										Object valObj = mtd.invoke(element);										if (valObj != null && valObj instanceof String) {											String val = valObj.toString();											if (name.equals("forId")) {												name = "for";											} else if (name.equals("acceptCharset")) {												name = "accept-charset";											} else if (name.equals("httpEquiv")) {												name = "http-equiv";											}											LabelValuePair lbp = new LabelValuePair();											lbp.setLabel(name);											lbp.setValue(val);											result.add(lbp);										}									}								} catch (Throwable e) {									// e.printStackTrace();								}							}						}					} catch (Throwable e) {						// e.printStackTrace();					}				}			}			cls = cls.getSuperclass();		}		return result;	}		/**	 * 	 * This method deeply analyses the Element and generates the HTML	 * presentation of the	 * 	 * Element class. The HTML is fully valid and XHTML compliant.	 * 	 * 	 * 	 * @param element	 * 	 * @return HTML Representation Of The Element	 */	public static String getToStringOut(Object element) {		// if it is text node simple return its content		if (element instanceof TextNode) {			return ((TextNode) element).getValue();		}		// we collect the attributes from the class's signature		// also we process the superclasses.		Class<?> cls = element.getClass();		String childOut = "";		Class<?> tmpCls = cls;		while (tmpCls != null) {			Method tmpMethods[] = tmpCls.getDeclaredMethods();			for (int i = 0; i < tmpMethods.length; i++) {				try {					Method tmpMethod = tmpMethods[i];					String tmpMethodName = tmpMethod.getName();					if (tmpMethodName.equals("getChildren")) {						Method mtdChildren = tmpCls.getDeclaredMethod("getChildren");						Object valChildren = mtdChildren.invoke(element);						if (valChildren != null && valChildren instanceof List) {							for (int m = 0; m < ((List<?>) valChildren).size(); m++) {								Object child = ((List<?>) valChildren).get(m);								childOut += getToStringOut(child);							}						}					}				} catch (Throwable e1) {					e1.printStackTrace();				}			}			tmpCls = tmpCls.getSuperclass();		}		// get the tag		String valTag = null;		try {			Method mtdTag = cls.getDeclaredMethod("getTag");			Object objTag = mtdTag.invoke(element);			if (objTag != null) {				valTag = objTag.toString();			}		} catch (Throwable e1) {			e1.printStackTrace();		}		String str = elementToHTML(element, valTag, cls, childOut);		return str;	}		/**	 * 	 * Marshalling method to parse from Element to HTML	 * 	 * 	 * 	 * @param element	 * 	 * @param valTag	 * 	 * @param cls	 * 	 * @param childOut	 * 	 * @return	 */	private static final String elementToHTML(Object element, String valTag, Class<?> cls, String childOut) {		StringBuffer output = new StringBuffer();		output.append("<").append(valTag);		Field fields[] = null;		Field tmpField = null;		Method methods[] = null;		while (cls != null) {			fields = cls.getDeclaredFields();			methods = cls.getDeclaredMethods();			if (fields != null && methods != null) {				for (int i = 0; i < fields.length; i++) {					try {						tmpField = fields[i];						String name = tmpField.getName();						// attribute names starting with underscores are used						// internally so						// they are ommitted from displayed						if (name != null && !name.startsWith("_") && !name.equals("children") && !name.equals("tag")) {							String methodName = getGetterMethodNameFromAttribute(name);							for (int j = 0; j < methods.length; j++) {								if (methods[j].getName().equals(methodName)) {									Method mtd = cls.getDeclaredMethod(methodName);									Object valObj = mtd.invoke(element);									if (valObj != null && valObj instanceof String) {										String val = valObj.toString();										if (name.equals("className")) {											output.append(" class=\"" + val + "\"");										} else if (name.equals("forId")) {											output.append(" for=\"" + val + "\"");										} else if (name.equals("acceptCharset")) {											output.append(" accept-charset=\"" + val + "\"");										} else if (name.equals("httpEquiv")) {											output.append(" http-equiv=\"" + val + "\"");										} else {											output.append(" " + name + "=\"" + val + "\"");										}									}								}							}						}					} catch (Throwable e) {						e.printStackTrace();					}				}			}			cls = cls.getSuperclass();		}		String str = Utility.extendedTrim(output.toString(), " ");		// set the inner text and append the tag closing		if (childOut != null && childOut.length() == 0) {			str += "/>";		} else {			str += ">" + childOut + "</" + valTag + ">";		}		return str;	}		/**	 * 	 * 	 * 	 * @param attName	 * 	 * @return	 */	private static final String getGetterMethodNameFromAttribute(String attName) {		if (attName == null || attName.trim().length() < 2) {			return null;		}		StringBuffer out = new StringBuffer();		out.append("get");		out.append(attName.substring(0, 1).toUpperCase(Locale.ENGLISH));		out.append(attName.substring(1));		return out.toString();	}}