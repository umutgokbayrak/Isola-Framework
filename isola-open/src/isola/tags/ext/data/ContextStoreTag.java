package isola.tags.ext.data;import isola.model.core.JsArray;import isola.model.core.JsObject;import isola.model.core.JsVariableImpl;import isola.model.ext.base.Observable;import isola.model.ext.data.ArrayReader;import isola.model.ext.data.Store;import isola.utility.Utility;import java.lang.reflect.Method;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Collection;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspTagException;/** *  * <p> * A datastore which automatically consumes Java objects which are in * pageContext, Request or *  * Session scopes. Automatically parses it using Java Reflection API and * converts them to javascript *  * arrays which are consumable by the ArrayStore. This DataStore type uses the * array data *  * store type underneath but a more complex method since it converts the Java * objects to Javascript *  * arrays. * </p> *  *  *  * <p> * This Data Store will need a Java Collection to be set to any of the scopes: * pageContext, *  * request and session. If no scope is set, the search order is also the same. * </p> *  *  *  * There are two attributes generally used for this data store type. *  * <ul> *  * <li><strong>httpAttribute</strong>: The name of the attribute which is set in * the page, request *  * or session</li> *  * <li><strong>httpScope</strong>: The scope where to search for. For * performance reasons it is *  * better to set it. Valid values are pageContext, request and session.</li> *  * </ul> *  *  *  * @author Umut Gokbayrak */public class ContextStoreTag extends StoreTag {	private static final long serialVersionUID = 3039114784586301047L;	private Object httpAttribute;	private String httpScope;	private String datePattern;		@Override	public int doEndTag() throws JspException {		Store obj = new Store();		prepareConfig(obj);		// manage listeners		prepareEvents(obj);		// print the output		ArrayReader arrReader = new ArrayReader();		arrReader.put("~~~NIL1", new JsObject());		arrReader.put("~~~NIL2", getFields());		obj.reader = arrReader;		printStore(obj);		clear();		return EVAL_PAGE;	}		@Override	public void clear() {		httpAttribute = null;		httpScope = null;		datePattern = null;		super.clear();	}		/**	 * 	 * 	 * 	 * @param obj	 */	@SuppressWarnings("cast")	protected void prepareConfig(Store obj) {		super.prepareConfig(obj);		if (httpAttribute != null) {			JsArray output = new JsArray();			try {				Object val = null;				if (httpAttribute instanceof String) {					Object tmp = null;					if (httpAttribute instanceof String) {						if (!((String) httpAttribute).startsWith("$")) {							tmp = Utility.getBeanValue("${" + httpAttribute + "}", pageContext, httpScope);						}					} else {						tmp = httpAttribute;					}					if (tmp != null && tmp instanceof Collection<?>) {						val = (Collection<?>) tmp;					} else {						if (httpAttribute instanceof String) {							tmp = Utility.getBeanValue(((String) httpAttribute), pageContext, httpScope);							if (tmp != null && tmp instanceof Collection<?>) {								val = (Collection<?>) tmp;							} else {								throw new JspTagException(httpAttribute + " must be a Java Collection ");							}						}					}				} else {					val = httpAttribute.toString();				}				if (val == null || !(val instanceof Collection)) {					throw new JspTagException(httpAttribute + " must be a Java Collection ");				}				Collection<?> col = (Collection<?>) val;				if (col.size() > 0) {					Iterator<?> iter = col.iterator();					JsArray row = null;					while (iter.hasNext()) {						row = new JsArray();						Object o = iter.next();						Class<?> cls = o.getClass();						JsArray columns = getFields();						for (int i = 0; i < columns.size(); i++) {							JsObject tmp = (JsObject) columns.get(i);							Object resObj = null;							if (o instanceof HashMap<?, ?>) {								resObj = ((HashMap<?, ?>) o).get(tmp.get("name"));							} else {								try {									Method mtd = cls.getDeclaredMethod(Utility.getGetterMethodNameFromAttribute(tmp.get("name").toString()), new Class[0]);									resObj = mtd.invoke(o, (Object[]) null);									if (resObj != null) {										if (resObj instanceof Calendar) {											Calendar cal = (Calendar) resObj;											resObj = cal.getTime();										}										if (resObj instanceof Date) {											if (datePattern == null) {												datePattern = "dd/MM/yyyy";											}											SimpleDateFormat sdf = new SimpleDateFormat(datePattern);											resObj = sdf.format((Date) resObj);										}									}								} catch (Exception e) {									throw new JspException(tmp.get("name").toString());								}							}							if (resObj != null) {								row.add(resObj.toString());							} else {								row.add(null);							}						}						output.add(row);					}				}			} catch (Exception e) {				e.printStackTrace();			}			obj.data = new JsVariableImpl(output.toString());		}	}		@Override	protected void prepareEvents(Observable obj) {		super.prepareEvents(obj);	}		/**	 * 	 * The name of the attribute which is set in the page, request or session	 * 	 * @param httpAttribute	 */	public void setHttpAttribute(String httpAttribute) {		this.httpAttribute = httpAttribute;	}		/**	 * 	 * The scope where to search for. For performance reasons it is better to	 * set it. Valid values	 * 	 * are pageContext, request and session	 * 	 * 	 * 	 * @param httpScope	 */	public void setHttpScope(String httpScope) {		this.httpScope = httpScope;	}	public void setDatePattern(String datePattern) {		this.datePattern = datePattern;	}}