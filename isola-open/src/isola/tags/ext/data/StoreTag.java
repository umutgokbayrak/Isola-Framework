package isola.tags.ext.data;import java.io.IOException;import javax.servlet.jsp.JspException;import isola.model.core.JsArray;import isola.model.core.JsFunction;import isola.model.core.JsObject;import isola.model.core.JsVariableImpl;import isola.model.ext.base.Observable;import isola.model.ext.data.DataProxy;import isola.model.ext.data.DataReader;import isola.model.ext.data.Store;import isola.tags.ext.base.ObservableTag;import isola.tags.ext.container.DataViewTag;import isola.tags.ext.form.ComboBoxTag;import isola.tags.ext.grid.GridPanelTag;import isola.tags.ext.toolbar.PagingToolbarTag;/** *  * <p> * <strong>Not needed to be used directly. Use any subclasses instead such ass * JSONStore, ArrayStore, *  * XMLStore, ContextStore etc...</strong> * </p> *  *  *  * <p> * The Store class encapsulates a client side cache of Record objects which * provide input data *  * for Components such as the GridPanel, the ComboBox, or the DataView * </p> *  *  *  * <p> * A Store object uses its configured implementation of DataProxy to access a * data object unless *  * you call loadData directly and pass in your data. * </p> *  *  *  * <p> * A Store object has no knowledge of the format of the data returned by the * Proxy. * </p> *  *  *  * <p> * A Store object uses its configured implementation of DataReader to create * Record instances *  * from the data object. These Records are cached and made available through * accessor functions. * </p> *  *  *  *  *  *  *  * @author Umut Gokbayrak */public class StoreTag extends ObservableTag {	private static final long serialVersionUID = -88886662192381402L;	private String autoLoad;	private String pruneModifiedRecords;	private String remoteSort;	private String storeId;	private String url;	private DataReader reader;	private JsObject sortInfo;	private JsObject baseParams;	private String data;	private DataProxy proxy;	private JsArray fields;	private String onAdd;	private String onBeforeLoad;	private String onClear;	private String onDataChanged;	private String onLoad;	private String onLoadException;	private String onMetaChange;	private String onRemove;	private String onUpdate;		@Override	public int doEndTag() throws JspException {		Store obj = new Store();		prepareConfig(obj);		// manage listeners		prepareEvents(obj);		// print the output		printStore(obj);		clear();		return EVAL_PAGE;	}		/**	 * 	 * 	 * 	 * @param obj	 */	protected void printStore(Store obj) {		if (getParent() instanceof DataViewTag) {			DataViewTag par = (DataViewTag) getParent();			par.setStore(obj);		} else if (getParent() instanceof GridPanelTag) {			GridPanelTag par = (GridPanelTag) getParent();			par.setStore(obj);		} else if (getParent() instanceof ComboBoxTag) {			ComboBoxTag par = (ComboBoxTag) getParent();			par.setStore(obj);		} else if (getParent() instanceof PagingToolbarTag) {			PagingToolbarTag par = (PagingToolbarTag) getParent();			par.setStore(obj);		} else {			try {				pageContext.getOut().write(obj.toString() + ";");			} catch (IOException e) {			}		}	}		@Override	public void clear() {		super.clear();		autoLoad = pruneModifiedRecords = remoteSort = storeId = url = null;		reader = null;		sortInfo = new JsObject();		baseParams = new JsObject();		data = null;		proxy = null;		onAdd = onBeforeLoad = onClear = onDataChanged = onLoad = null;		onLoadException = onMetaChange = onRemove = onUpdate = null;		fields = new JsArray();	}		/**	 * 	 * 	 * 	 * @param obj	 */	protected void prepareConfig(Store obj) {		if (autoLoad == null) {			autoLoad = "true";		}		try {			obj.autoLoad = Boolean.valueOf(autoLoad);		} catch (Exception e) {		}		if (pruneModifiedRecords != null) {			try {				obj.pruneModifiedRecords = Boolean.valueOf(pruneModifiedRecords);			} catch (Exception e) {			}		}		if (remoteSort != null) {			try {				obj.remoteSort = Boolean.valueOf(remoteSort);			} catch (Exception e) {			}		}		obj.storeId = storeId;		obj.url = url;		if (reader != null) {			obj.reader = reader;		}		if (sortInfo != null && sortInfo.size() > 0) {			obj.sortInfo = sortInfo;		}		if (baseParams != null && baseParams.size() > 0) {			obj.baseParams = baseParams;		}		if (data != null) {			obj.data = new JsVariableImpl(data);		}		if (proxy != null) {			obj.proxy = proxy;		}	}		@Override	protected void prepareEvents(Observable obj) {		super.prepareEvents(obj);		if (onAdd != null) {			obj.listeners.put("add", new JsFunction(onAdd));		}		if (onBeforeLoad != null) {			obj.listeners.put("beforeload", new JsFunction(onBeforeLoad));		}		if (onClear != null) {			obj.listeners.put("clear", new JsFunction(onClear));		}		if (onDataChanged != null) {			obj.listeners.put("datachanged", new JsFunction(onDataChanged));		}		if (onLoad != null) {			obj.listeners.put("load", new JsFunction(onLoad));		}		if (onLoadException != null) {			obj.listeners.put("loadexception", new JsFunction(onLoadException));		}		if (onMetaChange != null) {			obj.listeners.put("metachange", new JsFunction(onMetaChange));		}		if (onRemove != null) {			obj.listeners.put("remove", new JsFunction(onRemove));		}		if (onUpdate != null) {			obj.listeners.put("update", new JsFunction(onUpdate));		}	}		/**	 * 	 * If passed, this store's load method is automatically called after	 * creation with the autoLoad	 * 	 * object	 */	public void setAutoLoad(String autoLoad) {		this.autoLoad = autoLoad;	}		/**	 * 	 * True to clear all modified record information each time the store is	 * loaded or when a record	 * 	 * is removed. (defaults to false).	 */	public void setPruneModifiedRecords(String pruneModifiedRecords) {		this.pruneModifiedRecords = pruneModifiedRecords;	}		/**	 * 	 * <p>	 * True if sorting is to be handled by requesting the Proxy to provide a	 * refreshed version	 * 	 * of the data object in sorted order, as opposed to sorting the Record	 * cache in place	 * 	 * (defaults to false).	 * </p>	 * 	 * 	 * 	 * <p>	 * If remote sorting is specified, then clicking on a column header causes	 * the current	 * 	 * page to be requested from the server with the addition of the following	 * two parameters:	 * </p>	 * 	 * <ul>	 * 	 * <li>	 * 	 * <strong>sort(String):</strong>The name (as specified in the Record's	 * Field definition)	 * 	 * of the field to sort on.	 * 	 * </li>	 * 	 * <li>	 * 	 * <strong>dir(String):</strong>The direction of the sort, "ASC" or "DESC"	 * (case-sensitive).	 * 	 * </li>	 * 	 * </ul>	 */	public void setRemoteSort(String remoteSort) {		this.remoteSort = remoteSort;	}		/**	 * 	 * If passed, the id to use to register with the StoreMgr	 */	public void setStoreId(String storeId) {		this.storeId = storeId;	}		/**	 * 	 * If passed, an HttpProxy is created for the passed URL	 */	public void setUrl(String url) {		this.url = url;	}		/**	 * 	 * The DataReader object which processes the data object and returns an	 * Array of Ext.data.Record	 * 	 * objects which are cached keyed by their id property.	 */	public void setReader(DataReader reader) {		this.reader = reader;	}		/**	 * 	 * A config object in the format: {field: "fieldName", direction:	 * "ASC|DESC"}. The direction	 * 	 * property is case-sensitive.	 */	public void setSortInfo(JsObject sortInfo) {		this.sortInfo = sortInfo;	}		/**	 * 	 * An object containing properties which are to be sent as parameters on any	 * HTTP request	 */	public void setBaseParams(JsObject baseParams) {		this.baseParams = baseParams;	}		/**	 * 	 * The Proxy object which provides access to a data object.	 */	public void setProxy(DataProxy proxy) {		this.proxy = proxy;	}		/**	 * 	 * <p>	 * Fires when Records have been added to the Store	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * <li><strong>records</strong>:(Ext.data.Record[]) The array of Records	 * added</li>	 * 	 * <li><strong>index</strong>:(Number) The index at which the record(s) were	 * added</li>	 * 	 * </ul>	 * 	 * @param onAdd	 */	public void setOnAdd(String onAdd) {		this.onAdd = onAdd;	}		/**	 * 	 * <p>	 * Fires before a request is made for a new data object. If the beforeload	 * handler returns false	 * 	 * the load action will be canceled.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * <li><strong>options</strong>:(Object) The loading options that were	 * specified (see load for details)</li>	 * 	 * </ul>	 * 	 * @param onBeforeLoad	 */	public void setOnBeforeLoad(String onBeforeLoad) {		this.onBeforeLoad = onBeforeLoad;	}		/**	 * 	 * <p>	 * Fires when the data cache has been cleared.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * </ul>	 * 	 * @param onClear	 */	public void setOnClear(String onClear) {		this.onClear = onClear;	}		/**	 * 	 * <p>	 * Fires when the data cache has changed, and a widget which is using this	 * Store as a Record	 * 	 * cache should refresh its view.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * </ul>	 * 	 * @param onDataChanged	 */	public void setOnDataChanged(String onDataChanged) {		this.onDataChanged = onDataChanged;	}		/**	 * 	 * <p>	 * Fires after a new set of Records has been loaded.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * <li><strong>records</strong>:(Ext.data.Record[]) The Records that were	 * loaded</li>	 * 	 * <li><strong>options</strong>:(Object) The loading options that were	 * specified (see load for details)</li>	 * 	 * </ul>	 * 	 * @param onLoad	 */	public void setOnLoad(String onLoad) {		this.onLoad = onLoad;	}		/**	 * 	 * <p>	 * Fires if an exception occurs in the Proxy during loading. Called with the	 * signature of the	 * 	 * Proxy's "loadexception" event.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li>None</li>	 * 	 * </ul>	 * 	 * @param onLoadException	 */	public void setOnLoadException(String onLoadException) {		this.onLoadException = onLoadException;	}		/**	 * 	 * <p>	 * Fires when this store's reader provides new metadata (fields). This is	 * currently only supported	 * 	 * for JsonReaders.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * <li><strong>meta</strong>:(Object) The JSON metadata</li>	 * 	 * </ul>	 * 	 * @param onMetaChange	 */	public void setOnMetaChange(String onMetaChange) {		this.onMetaChange = onMetaChange;	}		/**	 * 	 * <p>	 * Fires when a Record has been removed from the Store	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * <li><strong>record</strong>:(Ext.data.Record) The Record that was removed	 * </li>	 * 	 * <li><strong>index</strong>:(Number) The index at which the record was	 * removed</li>	 * 	 * </ul>	 * 	 * @param onRemove	 */	public void setOnRemove(String onRemove) {		this.onRemove = onRemove;	}		/**	 * 	 * <p>	 * Fires when a Record has been updated	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Store</li>	 * 	 * <li><strong>record</strong>:(Ext.data.Record) The Record that was updated	 * </li>	 * 	 * <li><strong>operation</strong>:(String) The update operation being	 * performed. Value may be one of:</li>	 * 	 * <code>	 * Ext.data.Record.EDIT	 * Ext.data.Record.REJECT	 * Ext.data.Record.COMMIT
	 * </code>	 * 	 * </ul>	 * 	 * @param onUpdate	 */	public void setOnUpdate(String onUpdate) {		this.onUpdate = onUpdate;	}		/**	 * 	 * Inline data to be loaded when the store is initialized.	 */	public void setData(String data) {		this.data = data;	}		/**	 * 	 * Used by inner tags to populate the store mappings.	 * 	 * 	 * 	 * @param mappings	 */	public void setFields(JsArray mappings) {		this.fields = mappings;	}		public JsArray getFields() {		if (fields == null) {			fields = new JsArray();		}		return fields;	}		public String getData() {		return data;	}		public DataProxy getProxy() {		return proxy;	}		public String getUrl() {		return url;	}}