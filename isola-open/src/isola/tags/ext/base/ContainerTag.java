package isola.tags.ext.base;import javax.servlet.jsp.JspException;import isola.model.core.JsArray;import isola.model.core.JsFunction;import isola.model.core.JsObject;import isola.model.ext.base.Container;import isola.model.ext.base.Observable;import isola.model.ext.constants.XTypes;import isola.tags.ext.container.BoxComponentTag;/** *  * Base class for any Ext.BoxComponent that can contain other components. * Containers *  * handle the basic behavior of containing items, namely adding, inserting and *  * removing them. The specific layout logic required to visually render * contained *  * items is delegated to any one of the different layout classes available. *  * This class is intended to be extended and should generally not need to be *  * created directly via the new keyword. *  *  *  * @author Umut Gokbayrak *  *  */public class ContainerTag extends BoxComponentTag {	private static final long serialVersionUID = -2022336685058652499L;	private String activeItem;	private String autoDestroy;	private String bufferResize;	private String defaultType;	private String hideBorders;	private String layout;	private String monitorResize;	private JsArray items;	private JsObject defaults;	private JsObject layoutConfig;	private String onAdd;	private String onAfterLayout;	private String onBeforeAdd;	private String onBeforeRemove;	private String onRemove;		@Override	public int doEndTag() throws JspException {		Container obj = new Container();		prepareConfig(obj);		// manage listeners		prepareEvents(obj);		// print the output		printOut(obj);		return EVAL_PAGE;	}		@Override	public void clear() {		super.clear();		activeItem = null;		autoDestroy = "true";		bufferResize = defaultType = null;		hideBorders = layout = monitorResize = null;		onAdd = onAfterLayout = onBeforeAdd = onBeforeRemove = onRemove = null;		items = null;		defaults = null;		layoutConfig = null;	}		/**	 * 	 * 	 * 	 * @param obj	 */	protected void prepareConfig(Container obj) {		super.prepareConfig(obj);		obj.activeItem = activeItem;		if (autoDestroy != null) {			try {				obj.autoDestroy = Boolean.valueOf(autoDestroy);			} catch (Exception e) {			}		}		if (bufferResize != null) {			try {				obj.bufferResize = Integer.valueOf(bufferResize);			} catch (Exception e) {			}		}		obj.defaultType = defaultType;		if (hideBorders != null) {			try {				obj.hideBorders = Boolean.valueOf(hideBorders);			} catch (Exception e) {			}		}		obj.layout = layout;		if (monitorResize != null) {			try {				obj.monitorResize = Boolean.valueOf(monitorResize);			} catch (Exception e) {			}		}		if (defaults != null) {			obj.defaults = defaults;		}		if (layoutConfig != null) {			obj.layoutConfig = layoutConfig;		}		if (items != null) {			obj.items = items;		}	}		@Override	protected void prepareEvents(Observable obj) {		super.prepareEvents(obj);		if (onAdd != null) {			obj.listeners.put("add", new JsFunction(onAdd));		}		if (onAfterLayout != null) {			obj.listeners.put("afterlayout", new JsFunction(onAfterLayout));		}		if (onBeforeAdd != null) {			obj.listeners.put("beforeadd", new JsFunction(onBeforeAdd));		}		if (onBeforeRemove != null) {			obj.listeners.put("beforeremove", new JsFunction(onBeforeRemove));		}		if (onRemove != null) {			obj.listeners.put("remove", new JsFunction(onRemove));		}	}		public JsArray getItems() {		if (items == null) {			items = new JsArray();		}		return items;	}		/**	 * 	 * <p>	 * A single item, or an array of child Components to be added to this	 * 	 * container. Each item can be any type of object based on Ext.Component.	 * </p>	 * 	 * 	 * 	 * <p>	 * Component config objects may also be specified in order to avoid the	 * overhead of	 * 	 * constructing a real Component object if lazy rendering might mean that	 * the	 * 	 * added Component will not be rendered immediately. To take advantage of	 * this	 * 	 * "lazy instantiation", set the Ext.Component.xtype config property to the	 * registered	 * 	 * type of the Component wanted.	 * </p>	 * 	 * 	 * 	 * <p>	 * For a list of all available xtypes, see Ext.Component. If a single item	 * 	 * is being passed, it should be passed directly as an object reference	 * (e.g.,	 * 	 * items: {...}). Multiple items should be passed as an array of objects	 * 	 * (e.g., items: [{...}, {...}]).	 * </p>	 */	public void setItems(JsArray items) {		this.items = items;	}		/**	 * 	 * A string component id or the numeric index of the component that should	 * be	 * 	 * initially activated within the container's layout on render. For example,	 * 	 * activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the	 * 	 * container's collection). activeItem only applies to layout styles that	 * can	 * 	 * display items one at a time (like Ext.layout.Accordion,	 * 	 * Ext.layout.CardLayout and Ext.layout.FitLayout).	 * 	 * Related to Ext.layout.ContainerLayout.activeItem.	 */	public void setActiveItem(String activeItem) {		this.activeItem = activeItem;	}		/**	 * 	 * If true the container will automatically destroy any contained component	 * 	 * that is removed from it, else destruction must be handled manually	 * 	 * (defaults to true).	 */	public void setAutoDestroy(String autoDestroy) {		this.autoDestroy = autoDestroy;	}		/**	 * 	 * When set to true (100 milliseconds) or a number of milliseconds, the	 * 	 * layout assigned for this container will buffer the frequency it	 * calculates	 * 	 * and does a re-layout of components. This is useful for heavy containers	 * 	 * or containers with a large amount of sub components that frequent calls	 * 	 * to layout are expensive.	 */	public void setBufferResize(String bufferResize) {		this.bufferResize = bufferResize;	}		/**	 * 	 * The default type of container represented by this object as registered	 * 	 * in Ext.ComponentMgr (defaults to 'panel').	 * 	 * 	 * 	 * @see XTypes	 */	public void setDefaultType(String defaultType) {		this.defaultType = defaultType;	}		/**	 * 	 * True to hide the borders of each contained component, false to defer to	 * the	 * 	 * component's existing border settings (defaults to false).	 */	public void setHideBorders(String hideBorders) {		this.hideBorders = hideBorders;	}		/**	 * 	 * <p>	 * The layout type to be used in this container. If not specified, a default	 * 	 * Ext.layout.ContainerLayout will be created and used.	 * 	 * 	 * 	 * <p>	 * Valid values are:	 * </p>	 * 	 * <ul>	 * 	 * <li>accordion,</li>	 * 	 * <li>anchor,</li>	 * 	 * <li>border,</li>	 * 	 * <li>card,</li>	 * 	 * <li>column,</li>	 * 	 * <li>fit,</li>	 * 	 * <li>form</li>	 * 	 * <li>table.</li>	 * 	 * </ul>	 * 	 * <p>	 * Specific config values for the chosen layout type can be specified using	 * 	 * layoutConfig.	 * </p>	 */	public void setLayout(String layout) {		this.layout = layout;	}		/**	 * 	 * True to automatically monitor window resize events to handle anything	 * that is	 * 	 * sensitive to the current size of the viewport. This value is typically	 * managed	 * 	 * by the chosen layout and should not need to be set manually.	 */	public void setMonitorResize(String monitorResize) {		this.monitorResize = monitorResize;	}		/**	 * 	 * A config object that will be applied to all components added to this	 * container	 * 	 * either via the items config or via the add or insert methods.	 * 	 * The defaults config can contain any number of name/value property pairs	 * 	 * to be added to each item, and should be valid for the types of items	 * 	 * being added to the container. For example, to automatically apply padding	 * to	 * 	 * the body of each of a set of contained Ext.Panel items, you could pass:	 * 	 * defaults: {bodyStyle:'padding:15px'}.	 */	public void setDefaults(JsObject defaults) {		this.defaults = defaults;	}		/**	 * 	 * <p>	 * This is a config object containing properties specific to the chosen	 * layout	 * 	 * (to be used in conjunction with the layout config value). For complete	 * 	 * details regarding the valid config options for each layout type, see	 * 	 * the layout class corresponding to the type specified:	 * </p>	 * 	 * Ext.layout.Accordion	 * 	 * Ext.layout.AnchorLayout	 * 	 * Ext.layout.BorderLayout	 * 	 * Ext.layout.CardLayout	 * 	 * Ext.layout.ColumnLayout	 * 	 * Ext.layout.FitLayout	 * 	 * Ext.layout.FormLayout	 * 	 * Ext.layout.TableLayout	 */	public void setLayoutConfig(JsObject layoutConfig) {		this.layoutConfig = layoutConfig;	}		/**	 * 	 * <p>	 * Fires after any Ext.Component is added or inserted into the container.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Ext.Container</li>	 * 	 * <li><strong>component</strong>:(Ext.Component) The component that was	 * added</li>	 * 	 * <li><strong>index</strong>:(Number) The index at which the component was	 * added to the container's items collection</li>	 * 	 * </ul>	 * 	 * @param onAdd	 */	public void setOnAdd(String onAdd) {		this.onAdd = onAdd;	}		/**	 * 	 * <p>	 * Fires when the components in this container are arranged by the	 * associated layout manager.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Ext.Container</li>	 * 	 * <li><strong>layout</strong>:(ContainerLayout) The ContainerLayout	 * implementation for this container</li>	 * 	 * </ul>	 * 	 * @param onAfterLayout	 */	public void setOnAfterLayout(String onAfterLayout) {		this.onAfterLayout = onAfterLayout;	}		/**	 * 	 * <p>	 * Fires before any Ext.Component is added or inserted into the container. A	 * handler can return false to cancel the add.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Ext.Container</li>	 * 	 * <li><strong>component</strong>:(Ext.Component) The component being added</li>	 * 	 * <li><strong>index</strong>:(Number) The index at which the component will	 * be added to the container's items collection</li>	 * 	 * </ul>	 * 	 * @param onBeforeAdd	 */	public void setOnBeforeAdd(String onBeforeAdd) {		this.onBeforeAdd = onBeforeAdd;	}		/**	 * 	 * <p>	 * Fires before any Ext.Component is removed from the container. A handler	 * can return false to cancel the remove.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Ext.Container</li>	 * 	 * <li><strong>component</strong>: (Ext.Component) The component being	 * removed</li>	 * 	 * </ul>	 * 	 * @param onBeforeRemove	 */	public void setOnBeforeRemove(String onBeforeRemove) {		this.onBeforeRemove = onBeforeRemove;	}		/**	 * 	 * <p>	 * Fires after any Ext.Component is removed from the container	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Ext.Container</li>	 * 	 * <li><strong>component</strong>: (Ext.Component) The component that was	 * removed</li>	 * 	 * </ul>	 * 	 * @param onRemove	 */	public void setOnRemove(String onRemove) {		this.onRemove = onRemove;	}}