package isola.tags.ext.base;import java.util.StringTokenizer;import javax.servlet.jsp.JspException;import isola.model.core.JsArray;import isola.model.core.JsFunction;import isola.model.core.JsVariableImpl;import isola.model.ext.base.Component;import isola.model.ext.base.Observable;/** *  * <p> * <strong>This tag is extended by other classes and should not be used * directly. *  * </strong> * </p> *  *  *  * <p> * Base class for all Ext components. All subclasses of Component can * automatically *  * participate in the standard Ext component lifecycle of creation, rendering * and destruction. *  * They also have automatic support for basic hide/show and enable/disable * behavior. *  * Component allows any subclass to be lazy-rendered into any Ext.Container and * to be *  * automatically registered with the Ext.ComponentMgr so that it can be * referenced *  * at any time via Ext.getCmp. All visual widgets that require rendering into a * layout *  * should subclass Component (or Ext.BoxComponent if managed box model handling * is *  * required). * </p> *  *  *  * <p> * Every component has a specific xtype, which is its Ext-specific type name, *  * along with methods for checking the xtype like getXType and isXType. This is * the *  * list of all valid xtypes: * </p> *  *  *  * <pre> *  * xtype            Class * 
 * -------------    ------------------ * 
 * box              Ext.BoxComponent * 
 * button           Ext.Button * 
 * colorpalette     Ext.ColorPalette * 
 * component        Ext.Component * 
 * container        Ext.Container * 
 * cycle            Ext.CycleButton * 
 * dataview         Ext.DataView * 
 * datepicker       Ext.DatePicker * 
 * editor           Ext.Editor * 
 * editorgrid       Ext.grid.EditorGridPanel * 
 * grid             Ext.grid.GridPanel * 
 * paging           Ext.PagingToolbar * 
 * panel            Ext.Panel * 
 * progress         Ext.ProgressBar * 
 * splitbutton      Ext.SplitButton * 
 * tabpanel         Ext.TabPanel * 
 * treepanel        Ext.tree.TreePanel * 
 * viewport         Ext.ViewPort * 
 * window           Ext.Window * 
 *  * 
 * Toolbar components * 
 * --------------------------------------- * 
 * toolbar          Ext.Toolbar * 
 * tbbutton         Ext.Toolbar.Button * 
 * tbfill           Ext.Toolbar.Fill * 
 * tbitem           Ext.Toolbar.Item * 
 * tbseparator      Ext.Toolbar.Separator * 
 * tbspacer         Ext.Toolbar.Spacer * 
 * tbsplit          Ext.Toolbar.SplitButton * 
 * tbtext           Ext.Toolbar.TextItem * 
 *  * 
 * Form components * 
 * --------------------------------------- * 
 * form             Ext.FormPanel * 
 * checkbox         Ext.form.Checkbox * 
 * combo            Ext.form.ComboBox * 
 * datefield        Ext.form.DateField * 
 * field            Ext.form.Field * 
 * fieldset         Ext.form.FieldSet * 
 * hidden           Ext.form.Hidden * 
 * htmleditor       Ext.form.HtmlEditor * 
 * numberfield      Ext.form.NumberField * 
 * radio            Ext.form.Radio * 
 * textarea         Ext.form.TextArea * 
 * textfield        Ext.form.TextField * 
 * timefield        Ext.form.TimeField * 
 * trigger          Ext.form.TriggerField *  * </pre> *  *  *  * @author Umut Gokbayrak *  *  */public class ComponentTag extends ObservableTag {	private static final long serialVersionUID = 648195503380843471L;	private String allowDomMove;	private String applyTo;	private String autoShow;	private String cls;	private String ctCls;	private String disabledClass;	private String hideParent;	private String id;	private String renderTo;	private String stateId;	private String stateful;	private String style;	private String region;	private String hideMode;	private String plugins;	private JsArray stateEvents;	private String onBeforeDestroy;	private String onBeforeHide;	private String onBeforeRender;	private String onBeforeShow;	private String onBeforeStateRestore;	private String onBeforeStateSave;	private String onDestroy;	private String onDisable;	private String onEnable;	private String onHide;	private String onRender;	private String onShow;	private String onStateRestore;	private String onStateSave;		/**
	 * 
	 */	public int doEndTag() throws JspException {		Component obj = new Component();		prepareConfig(obj);		// manage listeners		prepareEvents(obj);		// print the output		printOut(obj);		return EVAL_PAGE;	}		@Override	public void clear() {		super.clear();		allowDomMove = "true";		applyTo = autoShow = cls = ctCls = null;		disabledClass = hideParent = id = renderTo = stateId = stateful = null;		style = region = hideMode = null;		onBeforeDestroy = onBeforeHide = onBeforeRender = onBeforeShow = null;		onBeforeStateRestore = onBeforeStateSave = onDestroy = onDisable = null;		onEnable = onHide = onRender = onShow = onStateRestore = onStateSave = null;		plugins = null;		stateEvents = null;	}		/**	 * 	 * 	 * 	 * @param obj	 */	protected void prepareConfig(Component obj) {		if (allowDomMove != null) {			try {				obj.allowDomMove = Boolean.valueOf(allowDomMove);			} catch (Exception e) {			}		}		obj.applyTo = applyTo;		if (autoShow != null) {			try {				obj.autoShow = Boolean.valueOf(autoShow);			} catch (Exception e) {			}		}		obj.cls = cls;		obj.ctCls = ctCls;		obj.disabledClass = disabledClass;		if (hideParent != null) {			try {				obj.hideParent = Boolean.valueOf(hideParent);			} catch (Exception e) {			}		}		obj.hideMode = hideMode;		obj.id = id;		obj.region = region;		obj.renderTo = renderTo;		obj.stateId = stateId;		if (stateful != null) {			try {				obj.stateful = Boolean.valueOf(stateful);			} catch (Exception e) {			}		}		obj.style = style;		if (plugins != null && plugins.trim().length() > 0) {			StringTokenizer token = new StringTokenizer(plugins, ",");			JsArray tmpPlugins = new JsArray();			while (token.hasMoreTokens()) {				tmpPlugins.add(new JsVariableImpl(token.nextToken()));			}			obj.plugins = tmpPlugins;		}		if (stateEvents != null && stateEvents.size() > 0) {			obj.stateEvents = stateEvents;		}	}		@Override	protected void prepareEvents(Observable obj) {		super.prepareEvents(obj);		if (onBeforeDestroy != null) {			obj.listeners.put("beforedestroy", new JsFunction(onBeforeDestroy));		}		if (onBeforeHide != null) {			obj.listeners.put("beforehide", new JsFunction(onBeforeHide));		}		if (onBeforeRender != null) {			obj.listeners.put("beforerender", new JsFunction(onBeforeRender));		}		if (onBeforeShow != null) {			obj.listeners.put("beforeshow", new JsFunction(onBeforeShow));		}		if (onBeforeStateRestore != null) {			obj.listeners.put("beforestaterestore", new JsFunction(onBeforeStateRestore));		}		if (onBeforeStateSave != null) {			obj.listeners.put("beforestateresave", new JsFunction(onBeforeStateSave));		}		if (onDestroy != null) {			obj.listeners.put("destroy", new JsFunction(onDestroy));		}		if (onDisable != null) {			obj.listeners.put("disable", new JsFunction(onDisable));		}		if (onEnable != null) {			obj.listeners.put("enable", new JsFunction(onEnable));		}		if (onHide != null) {			obj.listeners.put("hide", new JsFunction(onHide));		}		if (onRender != null) {			obj.listeners.put("render", new JsFunction(onRender));		}		if (onShow != null) {			obj.listeners.put("show", new JsFunction(onShow));		}		if (onStateRestore != null) {			obj.listeners.put("staterestore", new JsFunction(onStateRestore));		}		if (onStateSave != null) {			obj.listeners.put("statesave", new JsFunction(onStateSave));		}	}		/**	 * 	 * Whether the component can move the Dom node when rendering (defaults to	 * true).	 */	public void setAllowDomMove(String allowDomMove) {		this.allowDomMove = allowDomMove;	}		/**	 * 	 * The id of the node, a DOM node or an existing Element corresponding	 * 	 * to a DIV that is already present in the document that specifies some	 * 	 * structural markup for this component. When applyTo is used, constituent	 * 	 * parts of the component can also be specified by id or CSS class name	 * 	 * within the main element, and the component being created may attempt to	 * 	 * create its subcomponents from that markup if applicable. Using this	 * 	 * config, a call to render() is not required. If applyTo is specified,	 * 	 * any value passed for renderTo will be ignored and the target element's	 * 	 * parent node will automatically be used as the component's container.	 */	public void setApplyTo(String applyTo) {		this.applyTo = applyTo;	}		/**	 * 	 * True if the component should check for hidden classes (e.g. 'x-hidden'	 * 	 * or 'x-hide-display') and remove them on render (defaults to false).	 */	public void setAutoShow(String autoShow) {		this.autoShow = autoShow;	}		/**	 * 	 * An optional extra CSS class that will be added to this component's	 * 	 * Element (defaults to ''). This can be useful for adding customized styles	 * 	 * to the component or any of its children using standard CSS rules.	 */	public void setCls(String cls) {		this.cls = cls;	}		/**	 * 	 * An optional extra CSS class that will be added to this component's	 * 	 * container (defaults to ''). This can be useful for adding customized	 * 	 * styles to the container or any of its children using standard CSS rules.	 */	public void setCtCls(String ctCls) {		this.ctCls = ctCls;	}		/**	 * 	 * CSS class added to the component when it is disabled (defaults to	 * 	 * "x-item-disabled").	 */	public void setDisabledClass(String disabledClass) {		this.disabledClass = disabledClass;	}		/**	 * 	 * True to hide and show the component's container when hide/show is	 * 	 * called on the component, false to hide and show the component itself	 * 	 * (defaults to false). For example, this can be used as a shortcut	 * 	 * for a hide button on a window by setting hide:true on the button when	 * 	 * adding it to its parent container.	 */	public void setHideParent(String hideParent) {		this.hideParent = hideParent;	}		/**	 * 	 * The unique id of this component (defaults to an auto-assigned id).	 */	public void setId(String id) {		this.id = id;	}		/**	 * 	 * The id of the node, a DOM node or an existing Element that will be the	 * 	 * container to render this component into. Using this config, a call to	 * 	 * render() is not required.	 */	public void setRenderTo(String renderTo) {		this.renderTo = renderTo;	}		/**	 * 	 * The unique id for this component to use for state management purposes	 * 	 * (defaults to the component id). See stateful for an explanation of saving	 * 	 * and restoring Component state.	 */	public void setStateId(String stateId) {		this.stateId = stateId;	}		/**	 * 	 * <p>	 * A flag which causes the Component to attempt to restore the state of	 * 	 * internal properties from a saved state on startup.	 * </p>	 * 	 * 	 * 	 * <p>	 * For state saving to work, the state manager's provider must have been	 * 	 * set to an implementation of Ext.state.Provider which overrides the set	 * 	 * and get methods to save and recall name/value pairs. A built-in	 * 	 * implementation, Ext.state.CookieProvider is available.	 * </p>	 * 	 * 	 * 	 * <p>	 * To set the state provider for the current page:	 * </p>	 * 	 * <pre>	 * &lt;code&gt;	 * 
	 * Ext.state.Manager.setProvider(new Ext.state.CookieProvider());	 * 
	 * &lt;/code&gt;	 * </pre>	 * 	 * 	 * 	 * <p>	 * Components attempt to save state when one of the events listed in the	 * stateEvents	 * 	 * configuration fires.	 * </p>	 * 	 * 	 * 	 * <p>	 * You can perform extra processing on state save and restore by attaching	 * 	 * handlers to the beforestaterestore, staterestore, beforestatesave and	 * statesave	 * 	 * events.	 * </p>	 */	public void setStateful(String stateful) {		this.stateful = stateful;	}		/**	 * 	 * A custom style specification to be applied to this component's Element.	 * Should	 * 	 * be a valid argument to Ext.Element.applyStyles.	 */	public void setStyle(String style) {		this.style = style;	}		/**	 * 	 * Where to place this component. Valid values are south, north, west, east,	 * center	 */	public void setRegion(String region) {		this.region = region;	}		/**	 * 	 * How this component should hidden. Supported values are "visibility"	 * 	 * (css visibility), "offsets" (negative offset position) and "display"	 * 	 * (css display) - defaults to "display".	 */	public void setHideMode(String hideMode) {		this.hideMode = hideMode;	}		/**	 * 	 * An object or array of objects that will provide custom functionality	 * 	 * for this component. The only requirement for a valid plugin is that	 * 	 * it contain an init method that accepts a reference of type Ext.Component.	 * 	 * 	 * 	 * When a component is created, if any plugins are available, the component	 * 	 * will call the init method on each plugin, passing a reference to itself.	 * 	 * Each plugin can then call methods or respond to events on the	 * 	 * component as needed to provide its functionality.	 */	public void setPlugins(String plugins) {		this.plugins = plugins;	}		/**	 * 	 * An array of events that, when fired, should trigger this component to	 * 	 * save its state (defaults to none). These can be any types of events	 * supported	 * 	 * by this component, including browser or custom events	 * 	 * (e.g., ['click', 'customerchange']).	 * 	 * 	 * 	 * See stateful for an explanation of saving and restoring Component state.	 */	public void setStateEvents(JsArray stateEvents) {		this.stateEvents = stateEvents;	}		/**	 * 	 * <p>	 * Fires before the component is destroyed. Return false to stop the	 * destroy.	 * <p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onBeforeDestroy	 */	public void setOnBeforeDestroy(String onBeforeDestroy) {		this.onBeforeDestroy = onBeforeDestroy;	}		/**	 * 	 * <p>	 * Fires before the component is hidden. Return false to stop the hide.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onBeforeHide	 */	public void setOnBeforeHide(String onBeforeHide) {		this.onBeforeHide = onBeforeHide;	}		/**	 * 	 * <p>	 * Fires before the component is rendered. Return false to stop the render.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onBeforeRender	 */	public void setOnBeforeRender(String onBeforeRender) {		this.onBeforeRender = onBeforeRender;	}		/**	 * 	 * <p>	 * Fires before the component is shown. Return false to stop the show.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onBeforeShow	 */	public void setOnBeforeShow(String onBeforeShow) {		this.onBeforeShow = onBeforeShow;	}		/**	 * 	 * <p>	 * Fires before the state of the component is restored. Return false to stop	 * the restore.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * <li><strong>state</strong>:(Object) The hash of state values</li>	 * 	 * </ul>	 * 	 * @param onBeforeStateRestore	 */	public void setOnBeforeStateRestore(String onBeforeStateRestore) {		this.onBeforeStateRestore = onBeforeStateRestore;	}		/**	 * 	 * <p>	 * Fires before the state of the component is saved to the	 * 	 * configured state provider. Return false to stop the save.	 * <p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * <li><strong>state</strong>:(Object) The hash of state values</li>	 * 	 * </ul>	 * 	 * @param onBeforeStateSave	 */	public void setOnBeforeStateSave(String onBeforeStateSave) {		this.onBeforeStateSave = onBeforeStateSave;	}		/**	 * 	 * <p>	 * Fires after the component is destroyed.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onDestroy	 */	public void setOnDestroy(String onDestroy) {		this.onDestroy = onDestroy;	}		/**	 * 	 * <p>	 * Fires after the component is disabled.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onDisable	 */	public void setOnDisable(String onDisable) {		this.onDisable = onDisable;	}		/**	 * 	 * <p>	 * Fires after the component is enabled.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onEnable	 */	public void setOnEnable(String onEnable) {		this.onEnable = onEnable;	}		/**	 * 	 * <p>	 * Fires after the component is hidden.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onHide	 */	public void setOnHide(String onHide) {		this.onHide = onHide;	}		/**	 * 	 * <p>	 * Fires after the component is rendered.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onRender	 */	public void setOnRender(String onRender) {		this.onRender = onRender;	}		/**	 * 	 * <p>	 * Fires after the component is shown.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * </ul>	 * 	 * @param onShow	 */	public void setOnShow(String onShow) {		this.onShow = onShow;	}		/**	 * 	 * <p>	 * Fires after the state of the component is restored.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * <li><strong>state</strong>:(Object) The hash of state values</li>	 * 	 * </ul>	 * 	 * @param onStateRestore	 */	public void setOnStateRestore(String onStateRestore) {		this.onStateRestore = onStateRestore;	}		/**	 * 	 * <p>	 * Fires after the state of the component is saved to the configured state	 * provider.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>:Ext.Component</li>	 * 	 * <li><strong>state</strong>:(Object) The hash of state values</li>	 * 	 * </ul>	 * 	 * @param onStateSave	 */	public void setOnStateSave(String onStateSave) {		this.onStateSave = onStateSave;	}		public String getRenderTo() {		return renderTo;	}		public String getId() {		return id;	}		public JsArray getStateEvents() {		if (stateEvents == null) {			stateEvents = new JsArray();		}		return stateEvents;	}		public String getPlugins() {		return plugins;	}}