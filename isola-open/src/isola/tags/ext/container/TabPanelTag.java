package isola.tags.ext.container;import javax.servlet.jsp.JspException;import isola.model.core.JsFunction;import isola.model.ext.base.Observable;import isola.model.ext.container.TabPanel;/** *  * <p> * A basic tab container. Tab panels can be used exactly like a standard * Ext.Panel for layout purposes, *  * but also have special support for containing child Panels that get * automatically converted into tabs. * </p> *  *  *  * <p> * There is no actual tab class ï¿½ each tab is simply an Ext.Panel. However, when * rendered in a TabPanel, *  * each child Panel can fire additional events that only exist for tabs and are * not available to other *  * Panels. These are: * </p> *  *  *  * <ul> *  * <li><strong>activate</strong>Fires when this Panel becomes the active tab. * Listeners will be called *  * with the (tab : Panel) attribute. *  * </li> *  * <li><strong>deactivate</strong>Fires when this Panel that was the active tab * becomes deactivated. *  * Listeners will be called with the (tab : Panel) attribute. *  * </li> *  * </ul> *  *  *  * <p> * There are several methods available for creating TabPanels. The output of the * following examples *  * should be exactly the same. The tabs can be created and rendered completely * in code, as in this *  * example: * </p> *  *  *  * <pre> * &lt;code&gt; * 
 * var tabs = new Ext.TabPanel({ * 
 *     renderTo: Ext.getBody(), * 
 *     activeTab: 0, * 
 *     items: [{ * 
 *         title: 'Tab 1', * 
 *         html: 'A simple tab' * 
 *     },{ * 
 *         title: 'Tab 2', * 
 *         html: 'Another one' * 
 *     }] * 
 * }); * 
 * &lt;/code&gt; * </pre> *  *  *  * <p> * TabPanels can also be rendered from markup in a couple of ways. See the * autoTabs example for *  * rendering entirely from markup that is already structured correctly as a * TabPanel (a container div *  * with one or more nested tab divs with class 'x-tab'). You can also render * from markup that is not *  * strictly structured by simply specifying by id which elements should be the * container and the tabs. *  * Using this method, tab content can be pulled from different elements within * the page by id *  * regardless of page structure. Note that the tab divs in this example contain * the class *  *'x-hide-display' so that they can be rendered deferred without displaying * outside the tabs. *  * You could alternately set deferredRender to false to render all content tabs * on page load. *  * For example: * </p> *  *  *  * <pre> * &lt;code&gt; * 
 * var tabs = new Ext.TabPanel({ * 
 *     renderTo: 'my-tabs', * 
 *     activeTab: 0, * 
 *     items:[ * 
 *         {contentEl:'tab1', title:'Tab 1'}, * 
 *         {contentEl:'tab2', title:'Tab 2'} * 
 *     ] * 
 * }); * 
 * // Note that the tabs do not have to be nested within the container (although they can be) * 
 * &lt;div id=&quot;my-tabs&quot;&gt;&lt;/div&gt; * 
 * &lt;div id=&quot;tab1&quot; class=&quot;x-hide-display&quot;&gt;A simple tab&lt;/div&gt; * 
 * &lt;div id=&quot;tab2&quot; class=&quot;x-hide-display&quot;&gt;Another one&lt;/div&gt; * 
 * &lt;/code&gt; * </pre> *  *  *  * @author Umut Gokbayrak *  *  */public class TabPanelTag extends PanelTag {	private static final long serialVersionUID = -8803259722386055103L;	private String activeTab;	private String animScroll;	private String autoTabSelector;	private String autoTabs;	private String baseCls;	private String deferredRender;	private String layoutOnTabChange;	private String minTabWidth;	private String plain;	private String resizeTabs;	private String scrollDuration;	private String scrollIncrement;	private String scrollRepeatInterval;	private String tabMargin;	private String tabPosition;	private String tabWidth;	private String wheelIncrement;	private String onBeforeTabChange;	private String onContextMenu;	private String onTabChange;		@Override	public int doEndTag() throws JspException {		TabPanel obj = new TabPanel();		prepareConfig(obj);		// manage listeners		prepareEvents(obj);		// print the output		printOut(obj);		return EVAL_PAGE;	}		@Override	public void clear() {		super.clear();		activeTab = "0";		animScroll = deferredRender = "true";		autoTabSelector = baseCls = tabPosition = null;		autoTabs = layoutOnTabChange = plain = resizeTabs = "false";		minTabWidth = "30";		scrollDuration = "0.35";		scrollIncrement = "100";		scrollRepeatInterval = "400";		tabMargin = "2";		tabWidth = "120";		wheelIncrement = "20";	}		/**	 * 	 * 	 * 	 * @param obj	 */	protected void prepareConfig(TabPanel obj) {		super.prepareConfig(obj);		if (activeTab != null) {			try {				obj.activeTab = Integer.valueOf(activeTab);			} catch (Exception e) {			}		}		if (animScroll != null) {			try {				obj.animScroll = Boolean.valueOf(animScroll);			} catch (Exception e) {			}		}		obj.autoTabSelector = autoTabSelector;		obj.put("enableTabScroll", Boolean.valueOf(true));		if (autoTabs != null) {			try {				obj.autoTabs = Boolean.valueOf(autoTabs);			} catch (Exception e) {			}		}		obj.baseCls = baseCls;		if (deferredRender != null) {			try {				obj.deferredRender = Boolean.valueOf(deferredRender);			} catch (Exception e) {			}		}		if (layoutOnTabChange != null) {			try {				obj.layoutOnTabChange = Boolean.valueOf(layoutOnTabChange);			} catch (Exception e) {			}		}		if (minTabWidth != null) {			try {				obj.minTabWidth = Integer.valueOf(minTabWidth);			} catch (Exception e) {			}		}		if (plain != null) {			try {				obj.plain = Boolean.valueOf(plain);			} catch (Exception e) {			}		}		if (resizeTabs != null) {			try {				obj.resizeTabs = Boolean.valueOf(resizeTabs);			} catch (Exception e) {			}		}		if (scrollDuration != null) {			try {				obj.scrollDuration = Float.valueOf(scrollDuration);			} catch (Exception e) {			}		}		if (scrollIncrement != null) {			try {				obj.scrollIncrement = Integer.valueOf(scrollIncrement);			} catch (Exception e) {			}		}		if (scrollRepeatInterval != null) {			try {				obj.scrollRepeatInterval = Integer.valueOf(scrollRepeatInterval);			} catch (Exception e) {			}		}		if (tabMargin != null) {			try {				obj.tabMargin = Integer.valueOf(tabMargin);			} catch (Exception e) {			}		}		obj.tabPosition = tabPosition;		if (tabWidth != null) {			try {				obj.tabWidth = Integer.valueOf(tabWidth);			} catch (Exception e) {			}		}		if (wheelIncrement != null) {			try {				obj.wheelIncrement = Integer.valueOf(wheelIncrement);			} catch (Exception e) {			}		}	}		@Override	protected void prepareEvents(Observable obj) {		super.prepareEvents(obj);		if (onBeforeTabChange != null) {			obj.listeners.put("beforetabchange", new JsFunction(onBeforeTabChange));		}		if (onContextMenu != null) {			obj.listeners.put("contextmenu", new JsFunction(onContextMenu));		}		if (onTabChange != null) {			obj.listeners.put("tabchange", new JsFunction(onTabChange));		}	}		/**	 * 	 * Numeric index(0 based) of the tab that should be initially activated on	 * render	 * 	 * (defaults to none).	 */	public void setActiveTab(String activeTab) {		this.activeTab = activeTab;	}		/**	 * 	 * True to animate tab scrolling so that hidden tabs slide smoothly into	 * view	 * 	 * (defaults to true). Only applies when enableTabScroll = true.	 */	public void setAnimScroll(String animScroll) {		this.animScroll = animScroll;	}		/**	 * 	 * The CSS selector used to search for tabs in existing markup when autoTabs	 * = true	 * 	 * (defaults to 'div.x-tab'). This can be any valid selector supported by	 * 	 * Ext.DomQuery.select. Note that the query will be executed within the	 * scope of this tab	 * 	 * panel only (so that multiple tab panels from markup can be supported on a	 * page).	 */	public void setAutoTabSelector(String autoTabSelector) {		this.autoTabSelector = autoTabSelector;	}		/**	 * 	 * <p>	 * True to query the DOM for any divs with a class of 'x-tab' to be	 * automatically	 * 	 * converted to tabs and added to this panel (defaults to false). Note that	 * the query	 * 	 * will be executed within the scope of the container element only (so that	 * multiple	 * 	 * tab panels from markup can be supported via this method).	 * </p>	 * 	 * 	 * 	 * <p>	 * This method is only possible when the markup is structured correctly as a	 * 	 * container with nested divs containing the class 'x-tab'. To create	 * TabPanels without	 * 	 * these limitations, or to pull tab content from other elements on the	 * page, see the	 * 	 * example at the top of the class for generating tabs from markup.	 * </p>	 * 	 * 	 * 	 * <p>	 * There are a couple of things to note when using this method:	 * </p>	 * 	 * 	 * 	 * <p>	 * When using the autoTabs config (as opposed to passing individual tab	 * configs in the	 * 	 * TabPanel's items collection), you must use applyTo to correctly use the	 * specified id	 * 	 * as the tab container. The autoTabs method replaces existing content with	 * the TabPanel	 * 	 * components.	 * </p>	 * 	 * 	 * 	 * <p>	 * Make sure that you set deferredRender to false so that the content	 * elements for	 * 	 * each tab will be rendered into the TabPanel immediately upon page load,	 * otherwise they	 * 	 * will not be transformed until each tab is activated and will be visible	 * outside the	 * 	 * TabPanel.	 * </p>	 * 	 * 	 * 	 * <p>	 * Example usage:	 * </p>	 * 	 * 	 * 	 * <pre>	 * &lt;code&gt;	 * 
	 * var tabs = new Ext.TabPanel({	 * 
	 *     applyTo: 'my-tabs',	 * 
	 *     activeTab: 0,	 * 
	 *     deferredRender: false,	 * 
	 *     autoTabs: true	 * 
	 * });	 * 
	 * 	 * 
	 * // This markup will be converted to a TabPanel from the code above	 * 
	 * &lt;div id=&quot;my-tabs&quot;&gt;	 * 
	 *     &lt;div class=&quot;x-tab&quot; title=&quot;Tab 1&quot;&gt;A simple tab&lt;/div&gt;	 * 
	 *     &lt;div class=&quot;x-tab&quot; title=&quot;Tab 2&quot;&gt;Another one&lt;/div&gt;	 * 
	 * &lt;/div&gt;	 * 
	 * &lt;/code&gt;	 * </pre>	 */	public void setAutoTabs(String autoTabs) {		this.autoTabs = autoTabs;	}		/**	 * 	 * The base CSS class applied to the panel (defaults to 'x-tab-panel').	 */	public void setBaseCls(String baseCls) {		this.baseCls = baseCls;	}		/**	 * 	 * Internally, the TabPanel uses a Ext.layout.CardLayout to manage its tabs.	 * This property will	 * 	 * be passed on to the layout as its Ext.layout.CardLayout.deferredRender	 * config value,	 * 	 * determining whether or not each tab is rendered only when first accessed	 * (defaults to true).	 */	public void setDeferredRender(String deferredRender) {		this.deferredRender = deferredRender;	}		/**	 * 	 * Set to true to do a layout of tab items as tabs are changed.	 */	public void setLayoutOnTabChange(String layoutOnTabChange) {		this.layoutOnTabChange = layoutOnTabChange;	}		/**	 * 	 * The minimum width in pixels for each tab when resizeTabs = true (defaults	 * to 30).	 */	public void setMinTabWidth(String minTabWidth) {		this.minTabWidth = minTabWidth;	}		/**	 * 	 * True to render the tab strip without a background container image	 * (defaults to false).	 */	public void setPlain(String plain) {		this.plain = plain;	}		/**	 * 	 * True to automatically resize each tab so that the tabs will completely	 * fill the tab	 * 	 * strip (defaults to false). Setting this to true may cause specific widths	 * that might	 * 	 * be set per tab to be overridden in order to fit them all into view	 * (although minTabWidth	 * 	 * will always be honored).	 */	public void setResizeTabs(String resizeTabs) {		this.resizeTabs = resizeTabs;	}		/**	 * 	 * The number of milliseconds that each scroll animation should last	 * (defaults to .35). Only	 * 	 * applies when animScroll = true.	 */	public void setScrollDuration(String scrollDuration) {		this.scrollDuration = scrollDuration;	}		/**	 * 	 * The number of pixels to scroll each time a tab scroll button is pressed	 * (defaults to	 * 	 * 100, or if resizeTabs = true, the calculated tab width). Only applies	 * when	 * 	 * enableTabScroll = true.	 */	public void setScrollIncrement(String scrollIncrement) {		this.scrollIncrement = scrollIncrement;	}		/**	 * 	 * Number of milliseconds between each scroll while a tab scroll button is	 * continuously pressed	 * 	 * (defaults to 400).	 */	public void setScrollRepeatInterval(String scrollRepeatInterval) {		this.scrollRepeatInterval = scrollRepeatInterval;	}		/**	 * 	 * The number of pixels of space to calculate into the sizing and scrolling	 * of tabs. If you	 * 	 * change the margin in CSS, you will need to update this value so	 * calculations are correct with	 * 	 * either resizeTabs or scrolling tabs. (defaults to 2)	 */	public void setTabMargin(String tabMargin) {		this.tabMargin = tabMargin;	}		/**	 * 	 * The position where the tab strip should be rendered (defaults to 'top').	 * The only other supported	 * 	 * value is 'bottom'. Note that tab scrolling is only supported for position	 * 'top'.	 */	public void setTabPosition(String tabPosition) {		this.tabPosition = tabPosition;	}		/**	 * 	 * The initial width in pixels of each new tab (defaults to 120).	 */	public void setTabWidth(String tabWidth) {		this.tabWidth = tabWidth;	}		/**	 * 	 * For scrolling tabs, the number of pixels to increment on mouse wheel	 * scrolling (defaults to 20).	 */	public void setWheelIncrement(String wheelIncrement) {		this.wheelIncrement = wheelIncrement;	}		/**	 * 	 * <p>	 * Fires before the active tab changes. Handlers can return false to cancel	 * the tab change.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: TabPanel</li>	 * 	 * <li><strong>newTab</strong>:(Panel) The tab being activated</li>	 * 	 * <li><strong>currentTab</strong>:(Panel) The current active tab</li>	 * 	 * </ul>	 * 	 * @param onBeforeTabChange	 */	public void setOnBeforeTabChange(String onBeforeTabChange) {		this.onBeforeTabChange = onBeforeTabChange;	}		/**	 * 	 * <p>	 * Fires when the original browser contextmenu event originated from a tab	 * element.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: TabPanel</li>	 * 	 * <li><strong>tab</strong>:(Panel) The target tab</li>	 * 	 * <li><strong>e</strong>: EventObject</li>	 * 	 * </ul>	 * 	 * @param onContextMenu	 */	public void setOnContextMenu(String onContextMenu) {		this.onContextMenu = onContextMenu;	}		/**	 * 	 * <p>	 * Fires after the active tab has changed.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong>: TabPanel</li>	 * 	 * <li><strong>tab</strong>:(Panel) The new active tab</li>	 * 	 * </ul>	 * 	 * @param onTabChange	 */	public void setOnTabChange(String onTabChange) {		this.onTabChange = onTabChange;	}}