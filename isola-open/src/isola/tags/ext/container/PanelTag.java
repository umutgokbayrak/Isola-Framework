package isola.tags.ext.container;import javax.servlet.jsp.JspException;import javax.servlet.jsp.tagext.BodyContent;import isola.model.core.JsArray;import isola.model.core.JsFunction;import isola.model.core.JsObject;import isola.model.ext.base.Observable;import isola.model.ext.container.Panel;import isola.model.ext.toolbar.Toolbar;import isola.tags.ext.base.ContainerTag;/** *  * Panel is a container that has specific functionality and structural * components *  * that make it the perfect building block for application-oriented user * interfaces. *  * The Panel contains bottom and top toolbars, along with separate header, * footer *  * and body sections. It also provides built-in expandable and collapsible *  * behavior, along with a variety of prebuilt tool buttons that can be wired up * to *  * provide other customized behavior. Panels can be easily dropped into any *  * Container or layout, and the layout and rendering pipeline is completely * managed *  * by the framework. *  *  *  * @author Umut Gokbayrak *  *  */public class PanelTag extends ContainerTag {	private static final long serialVersionUID = 3878198096590377773L;	private String animCollapse;	private String autoScroll;	private String baseCls;	private String bodyBorder;	private String bodyStyle;	private String border;	private String bufferResize;	private String buttonAlign;	private String collapseFirst;	private String collapsed;	private String collapsedCls;	private String collapsible;	private String contentEl;	private String draggable;	private String elements;	private String floating;	private String footer;	private String frame;	private String header;	private String headerAsText;	private String hideCollapseTool;	private String html;	private String iconCls;	private String maskDisabled;	private String minButtonWidth;	private String shadow;	private String shadowOffset;	private String shim;	private String tabTip;	private String title;	private String titleCollapse;	private String xtype;	private String split;	private String anchor;	private String x;	private String y;	private String columnWidth;	private String rowSpan;	private String colSpan;	private String columns;	/**	 * 	 * TODO: Panel için Tool, Key tag'leri.	 */	private JsArray tools = new JsArray();	private Toolbar tbar;	private JsArray keys = new JsArray();	private JsArray buttons = new JsArray();	private Toolbar bbar;	private JsObject autoLoad = new JsObject();	private String onActivate;	private String onBeforeClose;	private String onBeforeCollapse;	private String onBeforeExpand;	private String onBodyResize;	private String onClose;	private String onCollapse;	private String onDeactivate;	private String onExpand;	private String onTitleChange;		@Override	public int doEndTag() throws JspException {		Panel obj = new Panel();		prepareConfig(obj);		// manage listeners		prepareEvents(obj);		// print the output		printOut(obj);		return EVAL_PAGE;	}		@Override	public void clear() {		super.clear();		autoScroll = baseCls = null;		bodyBorder = "true";		animCollapse = "true";		border = null;		collapseFirst = "true";		bodyStyle = null;		bufferResize = buttonAlign = null;		collapsed = collapsedCls = null;		collapsible = contentEl = draggable = elements = floating = footer = frame = null;		header = null;		headerAsText = "true";		hideCollapseTool = html = iconCls = null;		maskDisabled = "true";		minButtonWidth = null;		shadow = "true";		split = null;		shadowOffset = null;		shim = "true";		tabTip = title = titleCollapse = null;		tbar = null;		bbar = null;		anchor = x = y = columnWidth = rowSpan = colSpan = null;		keys = null;		buttons = null;		tools = null;		autoLoad = null;		columns = null;	}		/**	 * 	 * 	 * 	 * @param obj	 */	protected void prepareConfig(Panel obj) {		super.prepareConfig(obj);		if (animCollapse != null) {			try {				obj.animCollapse = Boolean.valueOf(animCollapse);			} catch (Exception e) {			}		}		if (autoScroll != null) {			try {				if (obj.defaults == null) {					obj.defaults = new JsObject();				}				obj.defaults.put("autoScroll", Boolean.valueOf(autoScroll));				obj.autoScroll = Boolean.valueOf(autoScroll);			} catch (Exception e) {			}		}		obj.baseCls = baseCls;		if (bodyBorder != null) {			try {				obj.bodyBorder = Boolean.valueOf(bodyBorder);			} catch (Exception e) {			}		} else {			obj.bodyBorder = false;		}		obj.bodyStyle = bodyStyle;		if (border != null) {			try {				obj.border = Boolean.valueOf(border);			} catch (Exception e) {			}		} else {			obj.border = false;		}		if (bufferResize != null) {			try {				obj.bufferResize = Integer.valueOf(bufferResize);			} catch (Exception e) {			}		}		obj.buttonAlign = buttonAlign;		if (collapseFirst != null) {			try {				obj.collapseFirst = Boolean.valueOf(collapseFirst);			} catch (Exception e) {			}		}		if (collapsed != null) {			try {				obj.collapsed = Boolean.valueOf(collapsed);			} catch (Exception e) {			}		}		obj.collapsedCls = collapsedCls;		if (collapsible != null) {			try {				obj.collapsible = Boolean.valueOf(collapsible);			} catch (Exception e) {			}		}		obj.contentEl = contentEl;		if (draggable != null) {			try {				obj.draggable = Boolean.valueOf(draggable);			} catch (Exception e) {			}		}		obj.elements = elements;		if (floating != null) {			try {				obj.floating = Boolean.valueOf(floating);			} catch (Exception e) {			}		}		if (footer != null) {			try {				obj.footer = Boolean.valueOf(footer);			} catch (Exception e) {			}		}		if (frame != null) {			try {				obj.frame = Boolean.valueOf(frame);			} catch (Exception e) {			}		}		if (header != null) {			try {				obj.header = Boolean.valueOf(header);			} catch (Exception e) {			}		}		if (headerAsText != null) {			try {				obj.headerAsText = Boolean.valueOf(headerAsText);			} catch (Exception e) {			}		}		if (hideCollapseTool != null) {			try {				obj.hideCollapseTool = Boolean.valueOf(hideCollapseTool);			} catch (Exception e) {			}		}		if (html != null) {			obj.html = html;		} else if (getEl() == null && contentEl == null && getRenderTo() == null) {			BodyContent bc = getBodyContent();			if (bc != null) {				String myHtml = bc.getString();				if (myHtml != null) {					myHtml = myHtml.trim();					if (myHtml.length() > 0) {						obj.html = getBodyContent().getString();					}				}			}		}		if (obj.html != null) {			obj.html = obj.html.replace("'", "\\'");			obj.html = obj.html.replace("\r", " ");			obj.html = obj.html.replace("\n", " ");			obj.html = obj.html.replace("\t", " ");			obj.html = obj.html.replace("  ", " ");		}		obj.iconCls = iconCls;		if (maskDisabled != null) {			try {				obj.maskDisabled = Boolean.valueOf(maskDisabled);			} catch (Exception e) {			}		}		if (minButtonWidth != null) {			try {				obj.minButtonWidth = Integer.valueOf(minButtonWidth);			} catch (Exception e) {			}		}		if (shadow != null) {			try {				obj.shadow = Boolean.valueOf(shadow);			} catch (Exception e) {			}		}		if (shadowOffset != null) {			try {				obj.shadowOffset = Integer.valueOf(shadowOffset);			} catch (Exception e) {			}		}		if (shim != null) {			try {				obj.shim = Boolean.valueOf(shim);			} catch (Exception e) {			}		}		obj.tabTip = tabTip;		obj.title = title;		if (xtype != null) {			obj.xtype = xtype;		}		if (titleCollapse != null) {			try {				obj.titleCollapse = Boolean.valueOf(titleCollapse);			} catch (Exception e) {			}		}		if (tools != null && tools.size() > 0) {			obj.tools = tools;		}		if (tbar != null) {			obj.tbar = tbar;		}		if (keys != null && keys.size() > 0) {			obj.keys = keys;		}		if (buttons != null && buttons.size() > 0) {			obj.buttons = buttons;		}		if (bbar != null) {			obj.bbar = bbar;		}		if (autoLoad != null && autoLoad.size() > 0) {			obj.autoLoad = autoLoad;		}		try {			if (split != null) {				obj.put("split", Boolean.valueOf(split));			}		} catch (Exception e) {		}		if (anchor != null) {			obj.put("anchor", anchor);		}		if (x != null) {			obj.put("x", x);		}		if (y != null) {			obj.put("y", y);		}		if (columnWidth != null) {			obj.put("columnWidth", columnWidth);		}		if (rowSpan != null) {			obj.put("rowspan", rowSpan);		}		if (colSpan != null) {			obj.put("colspan", colSpan);		}		if (columns != null) {			if (obj.layoutConfig == null) {				obj.layoutConfig = new JsObject();			}			obj.layoutConfig.put("columns", Integer.parseInt(columns));		}	}		@Override	protected void prepareEvents(Observable obj) {		super.prepareEvents(obj);		if (onActivate != null) {			obj.listeners.put("activate", new JsFunction(onActivate));		}		if (onBeforeClose != null) {			obj.listeners.put("beforeclose", new JsFunction(onBeforeClose));		}		if (onBeforeCollapse != null) {			obj.listeners.put("beforecollapse", new JsFunction(onBeforeCollapse));		}		if (onBeforeExpand != null) {			obj.listeners.put("beforeexpand", new JsFunction(onBeforeExpand));		}		if (onBodyResize != null) {			obj.listeners.put("bodyresize", new JsFunction(onBodyResize));		}		if (onClose != null) {			obj.listeners.put("close", new JsFunction(onClose));		}		if (onCollapse != null) {			obj.listeners.put("collapse", new JsFunction(onCollapse));		}		if (onDeactivate != null) {			obj.listeners.put("deactivate", new JsFunction(onDeactivate));		}		if (onExpand != null) {			obj.listeners.put("expand", new JsFunction(onExpand));		}		if (onTitleChange != null) {			obj.listeners.put("titlechange", new JsFunction(onTitleChange));		}	}		/**	 * 	 * True to animate the transition when the panel is collapsed, false to skip	 * 	 * the animation (defaults to true if the Ext.Fx class is available,	 * otherwise	 * 	 * false).	 */	public void setAnimCollapse(String animCollapse) {		this.animCollapse = animCollapse;	}		/**	 * 	 * True to use overflow:'auto' on the panel's body element and show scroll	 * bars	 * 	 * automatically when necessary, false to clip any overflowing content	 * 	 * (defaults to false).	 */	public void setAutoScroll(String autoScroll) {		this.autoScroll = autoScroll;	}		/**	 * 	 * The base CSS class to apply to this panel's element (defaults to	 * 'x-panel').	 */	public void setBaseCls(String baseCls) {		this.baseCls = baseCls;	}		/**	 * 	 * True to display an interior border on the body element of the panel,	 * false	 * 	 * to hide it (defaults to true). This only applies when border == true. If	 * 	 * border == true and bodyBorder == false, the border will display as a 1px	 * 	 * wide inset border, giving the entire body element an inset appearance.	 */	public void setBodyBorder(String bodyBorder) {		this.bodyBorder = bodyBorder;	}		/**	 * 	 * Custom CSS styles to be applied to the body element in the format	 * expected	 * 	 * by Ext.Element.applyStyles (defaults to null).	 */	public void setBodyStyle(String bodyStyle) {		this.bodyStyle = bodyStyle;	}		/**	 * 	 * True to display the borders of the panel's body element, false to hide	 * them	 * 	 * (defaults to true). By default, the border is a 2px wide inset border,	 * but	 * 	 * this can be further altered by setting bodyBorder to false.	 */	public void setBorder(String border) {		this.border = border;	}		/**	 * 	 * When set to true (100 milliseconds) or a number of milliseconds, the	 * layout	 * 	 * assigned for this container will buffer the frequency it calculates and	 * does	 * 	 * a re-layout of components. This is useful for heavy containers or	 * 	 * containers with a large amount of sub components that frequent calls to	 * 	 * layout are expensive.	 */	public void setBufferResize(String bufferResize) {		this.bufferResize = bufferResize;	}		/**	 * 	 * The alignment of any buttons added to this panel. Valid values are	 * 'right,'	 * 	 * 'left' and 'center' (defaults to 'right').	 */	public void setButtonAlign(String buttonAlign) {		this.buttonAlign = buttonAlign;	}		/**	 * 	 * True to make sure the collapse/expand toggle button always renders first	 * (to	 * 	 * the left of) any other tools in the panel's title bar, false to render it	 * 	 * last (defaults to true).	 */	public void setCollapseFirst(String collapseFirst) {		this.collapseFirst = collapseFirst;	}		/**	 * 	 * True to render the panel collapsed, false to render it expanded (defaults	 * to false).	 */	public void setCollapsed(String collapsed) {		this.collapsed = collapsed;	}		/**	 * 	 * A CSS class to add to the panel's element after it has been collapsed	 * (defaults	 * 	 * to 'x-panel-collapsed').	 */	public void setCollapsedCls(String collapsedCls) {		this.collapsedCls = collapsedCls;	}		/**	 * 	 * True to make the panel collapsible and have the expand/collapse toggle	 * button	 * 	 * automatically rendered into the header tool button area, false to keep	 * the	 * 	 * panel statically sized with no button (defaults to false).	 */	public void setCollapsible(String collapsible) {		this.collapsible = collapsible;	}		/**	 * 	 * The id of an existing HTML node to use as the panel's body content	 * (defaults to '').	 */	public void setContentEl(String contentEl) {		this.contentEl = contentEl;	}		/**	 * 	 * True to enable dragging of this Panel (defaults to false). For custom	 * drag/drop	 * 	 * implementations, an Ext.Panel.DD config could also be passed in this	 * config	 * 	 * instead of true, although Ext.Panel.DD is an internal, undocumented	 * class.	 */	public void setDraggable(String draggable) {		this.draggable = draggable;	}		/**	 * 	 * A comma-delimited list of panel elements to initialize when the panel is	 * 	 * rendered. Normally, this list will be generated automatically based on	 * the items	 * 	 * added to the panel at config time, but sometimes it might be useful to	 * make	 * 	 * sure a structural element is rendered even if not specified at config	 * time	 * 	 * (for example, you may want to add a button or toolbar dynamically after	 * the	 * 	 * panel has been rendered). Adding those elements to this list will	 * allocate	 * 	 * the required placeholders in the panel when it is rendered.	 * 	 * Valid values are	 * 	 * <ul>	 * 	 * <li>header</li>	 * 	 * <li>tbar (top bar)</li>	 * 	 * <li>body</li>	 * 	 * <li>bbar (bottom bar)</li>	 * 	 * <li>footer</li>	 * 	 * </ul>	 * 	 * Defaults to 'body'.	 */	public void setElements(String elements) {		this.elements = elements;	}		/**	 * 	 * True to float the panel (absolute position it with automatic shimming and	 * shadow),	 * 	 * false to display it inline where it is rendered (defaults to false). Note	 * that	 * 	 * by default, setting floating to true will cause the panel to display at	 * negative	 * 	 * offsets so that it is hidden -- because the panel is absolute positioned,	 * the	 * 	 * position must be set explicitly after render (e.g.,	 * myPanel.setPosition(100,100);).	 * 	 * Also, when floating a panel you should always assign a fixed width,	 * otherwise it	 * 	 * will be auto width and will expand to fill to the right edge of the	 * viewport.	 */	public void setFloating(String floating) {		this.floating = floating;	}		/**	 * 	 * True to create the footer element explicitly, false to skip creating it.	 * By	 * 	 * default, when footer is not specified, if one or more buttons have been	 * added	 * 	 * to the panel the footer will be created automatically, otherwise it will	 * not.	 */	public void setFooter(String footer) {		this.footer = footer;	}		/**	 * 	 * Shows a nice rounded corner with a thick border around the panel.	 */	public void setFrame(String frame) {		this.frame = frame;	}		/**	 * 	 * True to create the header element explicitly, false to skip creating it.	 * By	 * 	 * default, when header is not specified, if a title is set the header will	 * be	 * 	 * created automatically, otherwise it will not. If a title is set but	 * header is	 * 	 * explicitly set to false, the header will not be rendered.	 */	public void setHeader(String header) {		this.header = header;	}		/**	 * 	 * True to display the panel title in the header, false to hide it (defaults	 * to true).	 */	public void setHeaderAsText(String headerAsText) {		this.headerAsText = headerAsText;	}		/**	 * 	 * True to hide the expand/collapse toggle button when collapsible = true,	 * false	 * 	 * to display it (defaults to false).	 */	public void setHideCollapseTool(String hideCollapseTool) {		this.hideCollapseTool = hideCollapseTool;	}		/**	 * 	 * An HTML fragment, or a DomHelper specification to use as the panel's body	 * 	 * content (defaults to '').	 */	public void setHtml(String html) {		this.html = html;	}		/**	 * 	 * A CSS class that will provide a background image to be used as the panel	 * header	 * 	 * icon (defaults to '').	 */	public void setIconCls(String iconCls) {		this.iconCls = iconCls;	}		/**	 * 	 * True to mask the panel when it is disabled, false to not mask it	 * (defaults	 * 	 * to true). Either way, the panel will always tell its contained elements	 * to	 * 	 * disable themselves when it is disabled, but masking the panel can provide	 * an	 * 	 * additional visual cue that the panel is disabled.	 */	public void setMaskDisabled(String maskDisabled) {		this.maskDisabled = maskDisabled;	}		/**	 * 	 * Minimum width in pixels of all buttons in this panel (defaults to 75)	 */	public void setMinButtonWidth(String minButtonWidth) {		this.minButtonWidth = minButtonWidth;	}		/**	 * 	 * True (or a valid Ext.Shadow Ext.Shadow.mode value) to display a shadow	 * behind	 * 	 * the panel, false to display no shadow (defaults to 'sides'). Note that	 * this	 * 	 * option only applies when floating = true.	 */	public void setShadow(String shadow) {		this.shadow = shadow;	}		/**	 * 	 * The number of pixels to offset the shadow if displayed (defaults to 4).	 * Note	 * 	 * that this option only applies when floating = true.	 */	public void setShadowOffset(String shadowOffset) {		this.shadowOffset = shadowOffset;	}		/**	 * 	 * False to disable the iframe shim in browsers which need one (defaults to	 * true).	 * 	 * Note that this option only applies when floating = true.	 */	public void setShim(String shim) {		this.shim = shim;	}		/**	 * 	 * Adds a tooltip when mousing over the tab of a Ext.Panel which is an item	 * of a	 * 	 * Ext.TabPanel. Ext.QuickTips.init() must be called in order for the tips	 * to render.	 */	public void setTabTip(String tabTip) {		this.tabTip = tabTip;	}		/**	 * 	 * The title text to display in the panel header (defaults to ''). When a	 * title	 * 	 * is specified the header element will automatically be created and	 * displayed	 * 	 * unless header is explicitly set to false. If you don't want to specify a	 * title	 * 	 * at config time, but you may want one later, you must either specify a	 * non-empty	 * 	 * title (a blank space ' ' will do) or header:true so that the container	 * element	 * 	 * will get created.	 */	public void setTitle(String title) {		this.title = title;	}		/**	 * 	 * True to allow expanding and collapsing the panel (when collapsible =	 * true)	 * 	 * by clicking anywhere in the header bar, false to allow it only by	 * clicking to	 * 	 * tool button (defaults to false).	 */	public void setTitleCollapse(String titleCollapse) {		this.titleCollapse = titleCollapse;	}		/**	 * 	 * An array of tool button configs to be added to the header tool area. Each	 * tool	 * 	 * config may contain the following properties:	 * 	 * <ul>	 * 	 * <li><strong>id :</strong> String - <strong>Required</strong>. The type of	 * tool to create. Values may be	 * 	 * <ul>	 * 	 * <li>toggle (Created by default when collapsible is true)</li>	 * 	 * <li>close</li>	 * 	 * <li>minimize</li>	 * 	 * <li>maximize</li>	 * 	 * <li>restore</li>	 * 	 * <li>gear</li>	 * 	 * <li>pin</li>	 * 	 * <li>unpin</li>	 * 	 * <li>right</li>	 * 	 * <li>left</li>	 * 	 * <li>up</li>	 * 	 * <li>down</li>	 * 	 * <li>refresh</li>	 * 	 * <li>minus</li>	 * 	 * <li>plus</li>	 * 	 * <li>help</li>	 * 	 * <li>search</li>	 * 	 * <li>save</li>	 * 	 * </ul>	 * 	 * </li>	 * 	 * <li><strong>handler</strong> : Function - Required. The function to call	 * when clicked. Arguments passed are:	 * 	 * <ul>	 * 	 * <li><strong><i>event</i></strong>: Ext.EventObject The click event.</li>	 * 	 * <li><strong><i>toolEl</i></strong> : Ext.Element The tool Element.</li>	 * 	 * <li><strong><i>Panel</i></strong> : Ext.Panel The host Panel</li>	 * 	 * </ul>	 * 	 * </li>	 * 	 * <li><strong>scope</strong>:scope : Object - The scope in which to call	 * the handler.</li>	 * 	 * <li><strong>qtip</strong> : String/Object - A tip string, or a config	 * argument to Ext.QuickTip.register</li>	 * 	 * <li><strong>hidden</strong> : hidden : Boolean - True to initially render	 * hidden.</li>	 * 	 * <li><strong>on</strong> : Object - A listener config object specifiying	 * event listeners in the format of an argument to addListener</li>	 * 	 * </ul>	 * 	 * <pre>	 * &lt;code&gt;	 * 
	 * 	tools:[{	 * 
	 * 		id:'refresh',	 * 
	 * 		// hidden:true,	 * 
	 * 		handler: function(event, toolEl, panel){	 * 
	 * 		// refresh logic	 * 
	 * 		}	 * 
	 * }]	 * 
	 * &lt;/code&gt;	 * </pre>	 * 	 * Note that apart from the toggle tool which is provided when a panel is	 * collapsible, these tools only	 * 	 * provide the visual button. Any required functionality must be provided by	 * adding handlers that	 * 	 * implement the necessary behavior.	 */	public void setTools(JsArray tools) {		this.tools = tools;	}		/**	 * 	 * The top toolbar of the panel. This can be either an Ext.Toolbar object or	 * an	 * 	 * array of buttons/button configs to be added to the toolbar. Note that	 * this	 * 	 * is not available as a property after render. To access the top toolbar	 * after	 * 	 * render, use getTopToolbar.	 */	public void setTbar(Toolbar tbar) {		this.tbar = tbar;	}		/**	 * 	 * A KeyMap config object (in the format expected by Ext.KeyMap.addBinding	 * used	 * 	 * to assign custom key handling to this panel (defaults to null).	 */	public void setKeys(JsArray keys) {		this.keys = keys;	}		/**	 * 	 * An array of Ext.Button configs used to add buttons to the footer of this	 * panel.	 */	public void setButtons(JsArray buttons) {		this.buttons = buttons;	}		/**	 * 	 * The bottom toolbar of the panel. This can be a Ext.Toolbar object, a	 * toolbar	 * 	 * config, or an array of buttons/button configs to be added to the toolbar.	 * 	 * Note that this is not available as a property after render. To access the	 * 	 * bottom toolbar after render, use getBottomToolbar.	 */	public void setBbar(Toolbar bbar) {		this.bbar = bbar;	}		/**	 * 	 * <p>	 * A valid url spec according to the Updater Ext.Updater.update method. If	 * 	 * autoLoad is not null, the panel will attempt to load its contents	 * immediately	 * 	 * upon render.	 * </p>	 * 	 * <p>	 * The URL will become the default URL for this panel's body element, so	 * 	 * it may be refreshed at any time.	 * </p>	 */	public void setAutoLoad(JsObject autoLoad) {		this.autoLoad = autoLoad;	}		/**	 * 	 * <p>	 * Fires after the Panel has been visually activated. Note that Panels do	 * not directly support	 * 	 * being activated, but some Panel subclasses do (like Ext.Window). Panels	 * which are child Components	 * 	 * of a TabPanel fire the activate and deactivate events under the control	 * of the TabPanel.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) The Panel that has been activated.</li>	 * 	 * </ul>	 * 	 * @param onActivate	 */	public void setOnActivate(String onActivate) {		this.onActivate = onActivate;	}		/**	 * 	 * <p>	 * Fires before the Panel is closed. Note that Panels do not directly	 * support being closed, but some	 * 	 * Panel subclasses do (like Ext.Window). This event only applies to such	 * subclasses. A handler can	 * 	 * return false to cancel the close.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) The Panel being closed.</li>	 * 	 * </ul>	 * 	 * @param onBeforeClose	 */	public void setOnBeforeClose(String onBeforeClose) {		this.onBeforeClose = onBeforeClose;	}		/**	 * 	 * <p>	 * Fires before the Panel is collapsed. A handler can return false to cancel	 * the collapse.	 * <p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) the Panel being collapsed.</li>	 * 	 * <li><strong>animate</strong>:(Boolean) True if the collapse is animated,	 * else false.</li>	 * 	 * </ul>	 * 	 * @param onBeforeCollapse	 */	public void setOnBeforeCollapse(String onBeforeCollapse) {		this.onBeforeCollapse = onBeforeCollapse;	}		/**	 * 	 * <p>	 * Fires before the Panel is expanded. A handler can return false to cancel	 * the expand.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) The Panel being expanded.</li>	 * 	 * <li><strong>animate</strong>:(Boolean) True if the expand is animated,	 * else false.</li>	 * 	 * </ul>	 * 	 * @param onBeforeExpand	 */	public void setOnBeforeExpand(String onBeforeExpand) {		this.onBeforeExpand = onBeforeExpand;	}		/**	 * 	 * <p>	 * Fires after the Panel has been resized.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) the Panel which has been resized.</li>	 * 	 * <li><strong>width</strong>:(Number) The Panel's new width.</li>	 * 	 * <li><strong>height </strong>:(Number) The Panel's new height.</li>	 * 	 * </ul>	 * 	 * @param onBodyResize	 */	public void setOnBodyResize(String onBodyResize) {		this.onBodyResize = onBodyResize;	}		/**	 * 	 * <p>	 * Fires after the Panel is closed. Note that Panels do not directly support	 * being closed, but	 * 	 * some Panel subclasses do (like Ext.Window).	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) The Panel that has been closed.</li>	 * 	 * </ul>	 * 	 * @param onClose	 */	public void setOnClose(String onClose) {		this.onClose = onClose;	}		/**	 * 	 * <p>	 * Fires after the Panel has been collapsed.	 * <p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) the Panel that has been collapsed.</li>	 * 	 * </ul>	 * 	 * @param onCollapse	 */	public void setOnCollapse(String onCollapse) {		this.onCollapse = onCollapse;	}		/**	 * 	 * <p>	 * Fires after the Panel has been visually deactivated. Note that Panels do	 * not directly support	 * 	 * being deactivated, but some Panel subclasses do (like Ext.Window). Panels	 * which are child Components	 * 	 * of a TabPanel fire the activate and deactivate events under the control	 * of the TabPanel.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) The Panel that has been deactivated.</li>	 * 	 * </ul>	 * 	 * @param onDeactivate	 */	public void setOnDeactivate(String onDeactivate) {		this.onDeactivate = onDeactivate;	}		/**	 * 	 * <p>	 * Fires after the Panel has been expanded.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) The Panel that has been expanded.</li>	 * 	 * </ul>	 * 	 * @param onExpand	 */	public void setOnExpand(String onExpand) {		this.onExpand = onExpand;	}		/**	 * 	 * <p>	 * Fires after the Panel title has been set or changed.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>p</strong>:(Ext.Panel) The Panel which has had its title	 * changed.</li>	 * 	 * <li><strong>The</strong>:(String) new title.</li>	 * 	 * </ul>	 * 	 * @param onTitleChange	 */	public void setOnTitleChange(String onTitleChange) {		this.onTitleChange = onTitleChange;	}		public void setXtype(String xtype) {		this.xtype = xtype;	}		/**	 * 	 * If border layout is used then you can set this option to true to place a	 * splitbar	 * 	 * between the panels.	 * 	 * 	 * 	 * @param split	 */	public void setSplit(String split) {		this.split = split;	}		public JsArray getButtons() {		if (buttons == null) {			buttons = new JsArray();		}		return buttons;	}		/**	 * 	 * If anchor layout is used you can set an anchor value here.	 * 	 * @param anchor	 */	public void setAnchor(String anchor) {		this.anchor = anchor;	}		/**	 * 	 * If absolute layout is used you can set an absolute X position in pixels	 * to place the component in	 * 	 * the layout.	 * 	 * @param x	 */	public void setX(String x) {		this.x = x;	}		/**	 * 	 * If absolute layout is used you can set an absolute Y position in pixels	 * to place the component in	 * 	 * the layout.	 * 	 * @param y	 */	public void setY(String y) {		this.y = y;	}		/**	 * 	 * If column layout is used you can give a float column width from 0 to 1.	 * Valid example: .5	 * 	 * @param columnWidth	 */	public void setColumnWidth(String columnWidth) {		this.columnWidth = columnWidth;	}		/**	 * 	 * If table layout is used you can set rowspan as in an ordinary table.	 * 	 * 	 * 	 * @param rowspan	 */	public void setRowSpan(String rowspan) {		this.rowSpan = rowspan;	}		/**	 * 	 * If table layout is used you can set colspan as in an ordinary table.	 * 	 * 	 * 	 * @param colspan	 */	public void setColSpan(String colspan) {		this.colSpan = colspan;	}		public Toolbar getTbar() {		return tbar;	}		public Toolbar getBbar() {		return bbar;	}		public String getBorder() {		return border;	}		public void setColumns(String columns) {		this.columns = columns;	}}