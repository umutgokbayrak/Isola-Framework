package isola.tags.ext.window;import javax.servlet.jsp.JspException;import isola.model.core.JsFunction;import isola.model.ext.base.Observable;import isola.model.ext.window.Window;import isola.model.ext.window.WindowGroup;import isola.tags.ext.container.PanelTag;/** * A specialized panel intended for use as an application window. Windows are * floated and draggable by default, and also provide specific behavior like the ability to * maximize and restore (with an event for minimizing, since the minimize behavior is * application-specific). Windows can also be linked to a Ext.WindowGroup or * managed by the *  * Ext.WindowManager to provide grouping, activation, to front/back and other *  * application-specific behavior. *  * @author Umut Gokbayrak */public class WindowTag extends PanelTag {	private static final long serialVersionUID = -4153045874635984228L;	private String animateTarget;	private String baseCls;	private String closable;	private String closeAction;	private String constrain;	private String constrainHeader;	private String defaultButton;	private String draggable;	private String expandOnShow;	private String maximizable;	private String minHeight;	private String minWidth;	private String minimizable;	private String modal;	private String plain;	private String resizable;	private String resizeHandles;	private String onEsc;	private WindowGroup manager;	private String onMaximize;	private String onMinimize;	private String onRestore;		/**	 * 	 */	public int doEndTag() throws JspException {		Window obj = new Window();		prepareConfig(obj);		// manage listeners		prepareEvents(obj);		// print the output		printOut(obj);		return EVAL_PAGE;	}		@Override	public void clear() {		super.clear();		animateTarget = baseCls = null;		closable = "true";		closeAction = null;		constrain = "false";		constrainHeader = "false";		defaultButton = null;		draggable = expandOnShow = "true";		maximizable = "false";		minHeight = "100";		minWidth = "200";		minimizable = "false";		modal = plain = "false";		resizable = "true";		resizeHandles = null;		manager = null;		onEsc = null;		onMaximize = null;		onMinimize = onRestore = null;	}		/**	 * @param obj	 */	protected void prepareConfig(Window obj) {		super.prepareConfig(obj);		obj.animateTarget = animateTarget;		obj.baseCls = baseCls;		if (closable != null) {			try {				obj.closable = Boolean.valueOf(closable);			} catch (Exception e) {			}		}		obj.closeAction = closeAction;		if (constrain != null) {			try {				obj.constrain = Boolean.valueOf(constrain);			} catch (Exception e) {			}		}		if (constrainHeader != null) {			try {				obj.constrainHeader = Boolean.valueOf(constrainHeader);			} catch (Exception e) {			}		}		obj.defaultButton = defaultButton;		if (draggable != null) {			try {				obj.draggable = Boolean.valueOf(draggable);			} catch (Exception e) {			}		}		if (expandOnShow != null) {			try {				obj.expandOnShow = Boolean.valueOf(expandOnShow);			} catch (Exception e) {			}		}		if (maximizable != null) {			try {				obj.maximizable = Boolean.valueOf(maximizable);			} catch (Exception e) {			}		}		if (minHeight != null) {			try {				obj.minHeight = Integer.parseInt(minHeight);			} catch (Exception e) {			}		}		if (minWidth != null) {			try {				obj.minWidth = Integer.parseInt(minWidth);			} catch (Exception e) {			}		}		if (minimizable != null) {			try {				obj.minimizable = Boolean.valueOf(minimizable);			} catch (Exception e) {			}		}		if (modal != null) {			try {				obj.modal = Boolean.valueOf(modal);			} catch (Exception e) {			}		}		if (plain != null) {			try {				obj.plain = Boolean.valueOf(plain);			} catch (Exception e) {			}		}		if (resizable != null) {			try {				obj.resizable = Boolean.valueOf(resizable);			} catch (Exception e) {			}		}		obj.resizeHandles = resizeHandles;		if (onEsc != null) {			obj.onEsc = new JsFunction(onEsc);		}		if (manager != null) {			obj.manager = manager;		}	}		@Override	protected void prepareEvents(Observable obj) {		super.prepareEvents(obj);		if (onMaximize != null) {			obj.listeners.put("maximize", new JsFunction(onMaximize));		}		if (onMinimize != null) {			obj.listeners.put("minimize", new JsFunction(onMinimize));		}		if (onRestore != null) {			obj.listeners.put("restore", new JsFunction(onRestore));		}	}		/**	 * 	 * Id or element from which the window should animate while opening	 * (defaults to null	 * 	 * with no animation).	 */	public void setAnimateTarget(String animateTarget) {		this.animateTarget = animateTarget;	}		/**	 * 	 * The base CSS class to apply to this panel's element (defaults to	 * 'x-window').	 */	public void setBaseCls(String baseCls) {		this.baseCls = baseCls;	}		/**	 * 	 * True to display the 'close' tool button and allow the user to close the	 * window, false to hide	 * 	 * the button and disallow closing the window (default to true).	 */	public void setClosable(String closable) {		this.closable = closable;	}		/**	 * 	 * The action to take when the close button is clicked. The default action	 * is 'close'	 * 	 * which will actually remove the window from the DOM and destroy it. The	 * other valid	 * 	 * option is 'hide' which will simply hide the window by setting visibility	 * to hidden and	 * 	 * applying negative offsets, keeping the window available to be redisplayed	 * via the show	 * 	 * method.	 */	public void setCloseAction(String closeAction) {		this.closeAction = closeAction;	}		/**	 * 	 * True to constrain the window to the viewport, false to allow it to fall	 * outside of the	 * 	 * viewport (defaults to false). Optionally the header only can be	 * constrained using	 * 	 * constrainHeader.	 */	public void setConstrain(String constrain) {		this.constrain = constrain;	}		/**	 * 	 * True to constrain the window header to the viewport, allowing the window	 * body to fall	 * 	 * outside of the viewport, false to allow the header to fall outside the	 * viewport	 * 	 * (defaults to false). Optionally the entire window can be constrained	 * using constrain.	 */	public void setConstrainHeader(String constrainHeader) {		this.constrainHeader = constrainHeader;	}		/**	 * 	 * The id / index of a button or a button instance to focus when this window	 * received the focus.	 */	public void setDefaultButton(String defaultButton) {		this.defaultButton = defaultButton;	}		/**	 * 	 * True to allow the window to be dragged by the header bar, false to	 * disable dragging	 * 	 * (defaults to true). Note that by default the window will be centered in	 * the viewport,	 * 	 * so if dragging is disabled the window may need to be positioned	 * programmatically after	 * 	 * render (e.g., myWindow.setPosition(100, 100);).	 */	public void setDraggable(String draggable) {		this.draggable = draggable;	}		/**	 * 	 * True to always expand the window when it is displayed, false to keep it	 * in its current	 * 	 * state (which may be collapsed) when displayed (defaults to true).	 */	public void setExpandOnShow(String expandOnShow) {		this.expandOnShow = expandOnShow;	}		/**	 * 	 * True to display the 'maximize' tool button and allow the user to maximize	 * the window,	 * 	 * false to hide the button and disallow maximizing the window (defaults to	 * false). Note	 * 	 * that when a window is maximized, the tool button will automatically	 * change to a	 * 	 * 'restore' button with the appropriate behavior already built-in that will	 * restore the	 * 	 * window to its previous size.	 */	public void setMaximizable(String maximizable) {		this.maximizable = maximizable;	}		/**	 * 	 * The minimum height in pixels allowed for this window (defaults to 100).	 * Only applies	 * 	 * when resizable = true.	 */	public void setMinHeight(String minHeight) {		this.minHeight = minHeight;	}		/**	 * 	 * The minimum width in pixels allowed for this window (defaults to 200).	 * Only applies when	 * 	 * resizable = true.	 */	public void setMinWidth(String minWidth) {		this.minWidth = minWidth;	}		/**	 * 	 * True to display the 'minimize' tool button and allow the user to minimize	 * the window,	 * 	 * false to hide the button and disallow minimizing the window (defaults to	 * false). Note	 * 	 * that this button provides no implementation -- the behavior of minimizing	 * a window is	 * 	 * implementation-specific, so the minimize event must be handled and a	 * custom minimize	 * 	 * behavior implemented for this option to be useful.	 */	public void setMinimizable(String minimizable) {		this.minimizable = minimizable;	}		/**	 * 	 * True to make the window modal and mask everything behind it when	 * displayed, false to	 * 	 * display it without restricting access to other UI elements (defaults to	 * false).	 */	public void setModal(String modal) {		this.modal = modal;	}		/**	 * 	 * True to render the window body with a transparent background so that it	 * will blend	 * 	 * into the framing elements, false to add a lighter background color to	 * visually highlight	 * 	 * the body element and separate it more distinctly from the surrounding	 * frame	 * 	 * (defaults to false).	 */	public void setPlain(String plain) {		this.plain = plain;	}		/**	 * 	 * True to allow user resizing at each edge and corner of the window, false	 * to disable	 * 	 * resizing (defaults to true).	 */	public void setResizable(String resizable) {		this.resizable = resizable;	}		/**	 * 	 * A valid Ext.Resizable handles config string (defaults to 'all'). Only	 * applies when	 * 	 * resizable = true. Possible values:	 * 	 * <ul>	 * 	 * <li>'n': north</li>	 * 	 * <li>'s': south</li>	 * 	 * <li>'e': east</li>	 * 	 * <li>'w': west</li>	 * 	 * <li>'nw': northwest</li>	 * 	 * <li>'sw': southwest</li>	 * 	 * <li>'se': southeast</li>	 * 	 * <li>'ne': northeast</li>	 * 	 * <li>'all': all</li>	 * 	 * </ul>	 */	public void setResizeHandles(String resizeHandles) {		this.resizeHandles = resizeHandles;	}		/**	 * 	 * Allows override of the built-in processing for the escape key. Default	 * action is to	 * 	 * close the Window (performing whatever action is specified in closeAction.	 * To prevent	 * 	 * the Window closing when the escape key is pressed, specify this as	 * Ext.emptyFn	 * 	 * (See Ext.emptyFn).	 */	public void setOnEsc(String onEsc) {		this.onEsc = onEsc;	}		/**	 * 	 * A reference to the WindowGroup that should manage this window (defaults	 * to Ext.WindowMgr).	 */	public void setManager(WindowGroup manager) {		this.manager = manager;	}		/**	 * 	 * <p>	 * Fires after the window has been maximized.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong> : Ext.Window</li>	 * 	 * </ul>	 * 	 * @param onMaximize	 */	public void setOnMaximize(String onMaximize) {		this.onMaximize = onMaximize;	}		/**	 * 	 * <p>	 * Fires after the window has been minimized.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong> : Ext.Window</li>	 * 	 * </ul>	 * 	 * @param onMinimize	 */	public void setOnMinimize(String onMinimize) {		this.onMinimize = onMinimize;	}		/**	 * 	 * <p>	 * Fires after the window has been restored to its original size after being	 * maximized.	 * </p>	 * 	 * Listeners will be called with the following arguments:	 * 	 * <ul>	 * 	 * <li><strong>this</strong> : Ext.Window</li>	 * 	 * </ul>	 * 	 * @param onRestore	 */	public void setOnRestore(String onRestore) {		this.onRestore = onRestore;	}}